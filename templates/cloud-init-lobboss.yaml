#cloud-config
#
# Lobboss cloud-init -- CONTAINS NO SECRETS.
# Installs packages, scripts, and config skeletons.
# Secrets are pushed via SSH after boot by `lobmob deploy`.

package_update: true
package_upgrade: true

packages:
  - wireguard
  - git
  - jq
  - curl
  - unzip

write_files:
  # WireGuard skeleton -- private key injected by provision script
  - path: /etc/wireguard/wg0.conf.template
    permissions: "0600"
    content: |
      [Interface]
      PrivateKey = __WG_PRIVATE_KEY__
      Address = ${wg_subnet}.1/24
      ListenPort = 51820
      SaveConfig = true

  # Non-secret config only -- secrets appended by provision script
  - path: /etc/lobmob/env
    permissions: "0600"
    content: |
      VAULT_REPO=${vault_repo}
      PROJECT_NAME=${project_name}
      LOBSTER_SIZE=${lobster_size}
      REGION=${region}
      SSH_KEY_ID=${ssh_key_id}
      VPC_UUID=${vpc_uuid}
      LOBSTER_TAG=${lobster_tag}
      POOL_ACTIVE=1
      POOL_STANDBY=2

  # SSH config skeleton for GitHub -- deploy key pushed by provision script
  - path: /root/.ssh/config
    permissions: "0644"
    content: |
      Host github.com
        IdentityFile /root/.ssh/vault_key
        StrictHostKeyChecking accept-new

  # GitHub App token generator -- produces 1-hour installation tokens from PEM
  # Falls back gracefully if App not configured (returns empty, callers use PAT)
  - path: /usr/local/bin/lobmob-gh-token
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      # Load config
      if [ -f /etc/lobmob/env ]; then source /etc/lobmob/env; fi

      APP_ID="$${GH_APP_ID:-}"
      INSTALL_ID="$${GH_APP_INSTALL_ID:-}"
      PEM_FILE="$${GH_APP_PEM:-/etc/lobmob/gh-app.pem}"

      if [ -z "$$APP_ID" ] || [ -z "$$INSTALL_ID" ] || [ ! -f "$$PEM_FILE" ]; then
        exit 1
      fi

      # Base64url encode (RFC 4648 section 5)
      b64url() { openssl enc -base64 -A | tr '+/' '-_' | tr -d '='; }

      NOW=$$(date +%s)
      IAT=$$((NOW - 60))
      EXP=$$((NOW + 540))

      HEADER="eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9"
      PAYLOAD=$$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$$IAT" "$$EXP" "$$APP_ID" | b64url)
      SIGNATURE=$$(printf '%s' "$${HEADER}.$${PAYLOAD}" | openssl dgst -binary -sha256 -sign "$$PEM_FILE" | b64url)
      JWT="$${HEADER}.$${PAYLOAD}.$${SIGNATURE}"

      RESPONSE=$$(curl -s -X POST \
        -H "Authorization: Bearer $$JWT" \
        -H "Accept: application/vnd.github+json" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        "https://api.github.com/app/installations/$${INSTALL_ID}/access_tokens")

      if [[ "$$RESPONSE" =~ \"token\"[[:space:]]*:[[:space:]]*\"([^\"]+)\" ]]; then
        echo "$${BASH_REMATCH[1]}"
      else
        echo "ERROR: Failed to get installation token" >&2
        echo "$$RESPONSE" >&2
        exit 1
      fi

  # Web UI server -- OAuth callbacks, status dashboard, future management tools
  - path: /usr/local/bin/lobmob-web
    permissions: "0755"
    content: |
      #!/usr/bin/env node
      const http = require('http');
      const https = require('https');
      const { readFileSync, writeFileSync, existsSync } = require('fs');
      const { execSync } = require('child_process');

      const CERT_DIR = '/etc/lobmob/certs';
      const CERT_FILE = CERT_DIR + '/cert.pem';
      const KEY_FILE = CERT_DIR + '/key.pem';
      const HAS_CERTS = existsSync(CERT_FILE) && existsSync(KEY_FILE);
      const PORT = HAS_CERTS ? 443 : 8080;
      const ENV_FILE = '/etc/lobmob/secrets.env';
      const WEB_ENV = '/etc/lobmob/web.env';

      function loadEnv(path) {
        if (!existsSync(path)) return {};
        const env = {};
        readFileSync(path, 'utf8').split('\n').forEach(line => {
          const m = line.match(/^([A-Z_]+)=(.*)$$/);
          if (m) env[m[1]] = m[2];
        });
        return env;
      }

      function updateEnvVar(path, key, value) {
        if (!existsSync(path)) { writeFileSync(path, `$${key}=$${value}\n`); return; }
        let content = readFileSync(path, 'utf8');
        const re = new RegExp(`^$${key}=.*$$`, 'm');
        if (re.test(content)) {
          content = content.replace(re, `$${key}=$${value}`);
        } else {
          content += `\n$${key}=$${value}`;
        }
        writeFileSync(path, content);
      }

      function httpsPost(url, params, headers = {}) {
        return new Promise((resolve, reject) => {
          const body = new URLSearchParams(params).toString();
          const parsed = new URL(url);
          const req = https.request({
            hostname: parsed.hostname, path: parsed.pathname,
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': body.length, ...headers }
          }, res => {
            let data = '';
            res.on('data', c => data += c);
            res.on('end', () => resolve({ status: res.statusCode, body: data }));
          });
          req.on('error', reject);
          req.write(body);
          req.end();
        });
      }

      function fleetStatus() {
        try {
          const out = execSync('lobmob-fleet-status 2>/dev/null || echo "unavailable"', { timeout: 10000 }).toString();
          return out;
        } catch { return 'unavailable'; }
      }

      function fleetStatusJson() {
        try {
          const raw = execSync('lobmob-fleet-status --json 2>/dev/null', { timeout: 10000 }).toString();
          return JSON.parse(raw);
        } catch {
          // Fall back to parsing text output
          const text = fleetStatus();
          return { raw: text, parsed: false };
        }
      }

      function formatUptime(seconds) {
        const d = Math.floor(seconds / 86400);
        const h = Math.floor((seconds % 86400) / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        if (d > 0) return `$${d}d $${h}h $${m}m`;
        if (h > 0) return `$${h}h $${m}m`;
        return `$${m}m`;
      }

      const CSS = `
        :root {
          --bg: #0f1117;
          --surface: #1a1d27;
          --surface-hover: #222633;
          --border: #2a2e3d;
          --text: #e4e6ed;
          --text-muted: #8b8fa3;
          --accent: #e84142;
          --accent-glow: rgba(232, 65, 66, 0.15);
          --green: #34d399;
          --yellow: #fbbf24;
          --blue: #60a5fa;
          --radius: 12px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: var(--bg);
          color: var(--text);
          min-height: 100vh;
        }
        .container { max-width: 960px; margin: 0 auto; padding: 24px 20px; }
        header {
          display: flex; align-items: center; justify-content: space-between;
          padding: 20px 0; border-bottom: 1px solid var(--border); margin-bottom: 32px;
        }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { font-size: 36px; }
        .logo h1 { font-size: 24px; font-weight: 700; letter-spacing: -0.5px; }
        .logo span { color: var(--accent); }
        .header-actions { display: flex; gap: 8px; }
        .badge {
          display: inline-flex; align-items: center; gap: 6px;
          padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600;
          background: var(--surface); border: 1px solid var(--border);
        }
        .badge-green { color: var(--green); border-color: rgba(52, 211, 153, 0.3); background: rgba(52, 211, 153, 0.08); }
        .badge-yellow { color: var(--yellow); border-color: rgba(251, 191, 36, 0.3); background: rgba(251, 191, 36, 0.08); }
        .badge-red { color: var(--accent); border-color: rgba(232, 65, 66, 0.3); background: var(--accent-glow); }
        .dot { width: 6px; height: 6px; border-radius: 50%; }
        .dot-green { background: var(--green); box-shadow: 0 0 6px var(--green); }
        .dot-yellow { background: var(--yellow); }
        .dot-red { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 32px; }
        .card {
          background: var(--surface); border: 1px solid var(--border);
          border-radius: var(--radius); padding: 20px; transition: border-color 0.2s;
        }
        .card:hover { border-color: rgba(228, 230, 237, 0.15); }
        .card-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 8px; }
        .card-value { font-size: 28px; font-weight: 700; }
        .card-sub { font-size: 13px; color: var(--text-muted); margin-top: 4px; }
        .section { margin-bottom: 32px; }
        .section-title { font-size: 16px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
        .fleet-table { width: 100%; border-collapse: collapse; }
        .fleet-table th {
          text-align: left; padding: 10px 16px; font-size: 11px; text-transform: uppercase;
          letter-spacing: 1px; color: var(--text-muted); border-bottom: 1px solid var(--border);
          background: var(--surface);
        }
        .fleet-table td { padding: 12px 16px; border-bottom: 1px solid var(--border); font-size: 14px; }
        .fleet-table tr:hover td { background: var(--surface-hover); }
        .fleet-table-wrap {
          background: var(--surface); border: 1px solid var(--border);
          border-radius: var(--radius); overflow: hidden;
        }
        .status-raw {
          background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
          padding: 20px; font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 13px;
          line-height: 1.6; white-space: pre-wrap; overflow-x: auto; color: var(--text-muted);
        }
        .btn {
          display: inline-flex; align-items: center; gap: 8px;
          padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 500;
          text-decoration: none; transition: all 0.2s; cursor: pointer; border: none;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: #d13536; box-shadow: 0 4px 12px var(--accent-glow); }
        .btn-ghost { background: transparent; color: var(--text-muted); border: 1px solid var(--border); }
        .btn-ghost:hover { background: var(--surface); color: var(--text); }
        footer {
          padding: 20px 0; border-top: 1px solid var(--border); margin-top: 40px;
          display: flex; justify-content: space-between; align-items: center;
          font-size: 12px; color: var(--text-muted);
        }
        .refresh-note { font-size: 12px; color: var(--text-muted); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .loading { animation: pulse 1.5s ease-in-out infinite; }
        @media (max-width: 640px) {
          .grid { grid-template-columns: 1fr; }
          header { flex-direction: column; gap: 12px; align-items: flex-start; }
          .card-value { font-size: 22px; }
          .fleet-table { font-size: 13px; }
          .fleet-table th, .fleet-table td { padding: 8px 12px; }
        }
      `;

      function parseLobsters(raw) {
        // Try to parse fleet-status text into structured data
        const lines = raw.split('\\n').filter(l => l.trim());
        const lobsters = [];
        let current = null;
        for (const line of lines) {
          // Look for lobster entries like "lobster-xxx  active  10.13.37.x"
          const m = line.match(/^\\s*(lobster-\\S+|lobboss)\\s+(active|sleeping|standby|offline|provisioning|error)\\s*(.*)/i);
          if (m) {
            current = { name: m[1], status: m[2].toLowerCase(), info: m[3].trim() };
            lobsters.push(current);
          }
        }
        return lobsters;
      }

      function statusBadge(status) {
        const map = {
          active: '<span class="badge badge-green"><span class="dot dot-green"></span>Active</span>',
          sleeping: '<span class="badge"><span class="dot dot-yellow"></span>Sleeping</span>',
          standby: '<span class="badge badge-yellow"><span class="dot dot-yellow"></span>Standby</span>',
          offline: '<span class="badge"><span class="dot"></span>Offline</span>',
          provisioning: '<span class="badge badge-yellow"><span class="dot dot-yellow"></span>Provisioning</span>',
          error: '<span class="badge badge-red"><span class="dot dot-red"></span>Error</span>',
        };
        return map[status] || `<span class="badge">$${status}</span>`;
      }

      function dashboardHtml(statusText) {
        const esc = (s) => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        const lobsters = parseLobsters(statusText);
        const uptime = formatUptime(process.uptime());
        const activeCount = lobsters.filter(l => l.status === 'active').length;
        const totalCount = lobsters.length;

        let fleetSection;
        if (lobsters.length > 0) {
          const rows = lobsters.map(l => `
            <tr>
              <td style="font-weight:500">$${esc(l.name)}</td>
              <td>$${statusBadge(l.status)}</td>
              <td style="color:var(--text-muted)">$${esc(l.info)}</td>
            </tr>`).join('');
          fleetSection = `
            <div class="fleet-table-wrap">
              <table class="fleet-table">
                <thead><tr><th>Name</th><th>Status</th><th>Details</th></tr></thead>
                <tbody>$${rows}</tbody>
              </table>
            </div>`;
        } else {
          fleetSection = `<div class="status-raw" id="fleet-raw">$${esc(statusText)}</div>`;
        }

        return `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>lobmob ‚Äî Fleet Dashboard</title>
        <style>$${CSS}</style>
      </head>
      <body>
        <div class="container">
          <header>
            <div class="logo">
              <span class="logo-icon">ü¶û</span>
              <h1>lob<span>mob</span></h1>
            </div>
            <div class="header-actions">
              <span class="badge badge-green"><span class="dot dot-green"></span>Online</span>
            </div>
          </header>

          <div class="grid">
            <div class="card">
              <div class="card-label">Fleet Size</div>
              <div class="card-value">$${totalCount || '‚Äî'}</div>
              <div class="card-sub">$${activeCount} active</div>
            </div>
            <div class="card">
              <div class="card-label">Uptime</div>
              <div class="card-value">$${uptime}</div>
              <div class="card-sub">lobboss process</div>
            </div>
            <div class="card">
              <div class="card-label">Server</div>
              <div class="card-value" style="font-size:18px">lobboss</div>
              <div class="card-sub">WireGuard mesh</div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">ü¶û Fleet Status</div>
            $${fleetSection}
            <p class="refresh-note" style="margin-top:12px">Auto-refreshes every 30s ¬∑ <a href="/api/status" style="color:var(--blue);text-decoration:none">API</a></p>
          </div>

          <div class="section">
            <div class="section-title">‚ö° Quick Actions</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap">
              <a href="/oauth/digitalocean" class="btn btn-primary">Connect DigitalOcean</a>
              <a href="/health" class="btn btn-ghost">Health Check</a>
            </div>
          </div>

          <footer>
            <span>lobmob fleet management</span>
            <span>port $${PORT}</span>
          </footer>
        </div>
        <script>
          setInterval(async () => {
            try {
              const r = await fetch('/api/status');
              if (!r.ok) return;
              // Reload page on successful fetch to update fleet data
              location.reload();
            } catch {}
          }, 30000);
        </script>
      </body>
      </html>`;
      }

      function oauthSuccessHtml() {
        return `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>lobmob ‚Äî OAuth Complete</title>
        <style>$${CSS}</style>
      </head>
      <body>
        <div class="container" style="display:flex;align-items:center;justify-content:center;min-height:80vh">
          <div style="text-align:center">
            <div style="font-size:64px;margin-bottom:16px">‚úÖ</div>
            <h2 style="margin-bottom:8px">DigitalOcean Connected</h2>
            <p style="color:var(--text-muted);margin-bottom:24px">OAuth tokens have been stored. You can close this tab.</p>
            <a href="/" class="btn btn-ghost">‚Üê Back to Dashboard</a>
          </div>
        </div>
      </body>
      </html>`;
      }

      function notFoundHtml() {
        return `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>lobmob ‚Äî 404</title>
        <style>$${CSS}</style>
      </head>
      <body>
        <div class="container" style="display:flex;align-items:center;justify-content:center;min-height:80vh">
          <div style="text-align:center">
            <div style="font-size:64px;margin-bottom:16px">ü¶û</div>
            <h2 style="margin-bottom:8px">Page Not Found</h2>
            <p style="color:var(--text-muted);margin-bottom:24px">This lobster wandered off.</p>
            <a href="/" class="btn btn-primary">‚Üê Back to Dashboard</a>
          </div>
        </div>
      </body>
      </html>`;
      }

      const handler = async (req, res) => {
        const url = new URL(req.url, `http://$${req.headers.host}`);

        if (url.pathname === '/health') {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ status: 'ok', uptime: process.uptime() }));
          return;
        }

        if (url.pathname === '/api/status') {
          const data = fleetStatusJson();
          data.uptime = process.uptime();
          res.writeHead(200, { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' });
          res.end(JSON.stringify(data));
          return;
        }

        if (url.pathname === '/oauth/digitalocean') {
          const webEnv = loadEnv(WEB_ENV);
          const clientId = webEnv.DO_OAUTH_CLIENT_ID;
          if (!clientId) {
            res.writeHead(500); res.end('DO_OAUTH_CLIENT_ID not configured in web.env'); return;
          }
          const proto = HAS_CERTS ? "https" : "http";
          const callbackUrl = proto + "://" + req.headers.host + "/oauth/digitalocean/callback";
          const authUrl = `https://cloud.digitalocean.com/v1/oauth/authorize?response_type=code&client_id=$${clientId}&redirect_uri=$${encodeURIComponent(callbackUrl)}&scope=read+write`;
          res.writeHead(302, { Location: authUrl });
          res.end();
          return;
        }

        if (url.pathname === '/oauth/digitalocean/callback') {
          const code = url.searchParams.get('code');
          if (!code) { res.writeHead(400); res.end('Missing code parameter'); return; }
          const webEnv = loadEnv(WEB_ENV);
          const proto = HAS_CERTS ? "https" : "http";
          const callbackUrl = proto + "://" + req.headers.host + "/oauth/digitalocean/callback";
          try {
            const tokenRes = await httpsPost('https://cloud.digitalocean.com/v1/oauth/token', {
              grant_type: 'authorization_code',
              code,
              client_id: webEnv.DO_OAUTH_CLIENT_ID,
              client_secret: webEnv.DO_OAUTH_CLIENT_SECRET,
              redirect_uri: callbackUrl
            });
            const data = JSON.parse(tokenRes.body);
            if (data.access_token) {
              updateEnvVar(ENV_FILE, 'DO_OAUTH_TOKEN', data.access_token);
              updateEnvVar(ENV_FILE, 'DO_OAUTH_REFRESH', data.refresh_token);
              res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(oauthSuccessHtml());
            } else {
              res.writeHead(500); res.end('Token exchange failed: ' + tokenRes.body);
            }
          } catch (e) {
            res.writeHead(500); res.end('Error: ' + e.message);
          }
          return;
        }

        if (url.pathname === '/') {
          const status = fleetStatus();
          res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(dashboardHtml(status));
          return;
        }

        res.writeHead(404, { 'Content-Type': 'text/html' }); res.end(notFoundHtml());
      });

      };

      const server = HAS_CERTS
        ? https.createServer({ cert: readFileSync(CERT_FILE), key: readFileSync(KEY_FILE) }, handler)
        : http.createServer(handler);

      server.listen(PORT, '0.0.0.0', () => {
        const proto = HAS_CERTS ? "https" : "http";
        console.log(`lobmob-web listening on $${proto}://0.0.0.0:$${PORT}`);
      });

  # Web UI systemd service
  - path: /etc/systemd/system/lobmob-web.service
    permissions: "0644"
    content: |
      [Unit]
      Description=lobmob Web UI
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/bin/node /usr/local/bin/lobmob-web
      Restart=on-failure
      RestartSec=5
      StandardOutput=append:/var/log/lobmob-web.log
      StandardError=append:/var/log/lobmob-web.log

      [Install]
      WantedBy=multi-user.target

  # TLS certificate management via Let's Encrypt IP certs (lego)
  - path: /usr/local/bin/lobmob-cert
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      CERT_DIR="/etc/lobmob/certs"
      LEGO_DIR="/etc/lobmob/lego"
      EMAIL="$${ALERT_EMAIL:-admin@lobmob.swarm}"
      mkdir -p "$$CERT_DIR" "$$LEGO_DIR"

      # Get the reserved (public) IP
      PUBLIC_IP=$(curl -s http://169.254.169.254/metadata/v1/interfaces/public/0/ipv4/address)
      if [ -z "$$PUBLIC_IP" ]; then
        echo "ERROR: Could not determine public IP" >&2
        exit 1
      fi

      # Install lego if not present
      if ! command -v lego >/dev/null 2>&1; then
        LEGO_VERSION="4.21.0"
        curl -fsSL "https://github.com/go-acme/lego/releases/download/v$${LEGO_VERSION}/lego_v$${LEGO_VERSION}_linux_amd64.tar.gz" \
          | tar -xz -C /usr/local/bin lego
        echo "lego installed"
      fi

      # Issue or renew certificate
      if [ -f "$$LEGO_DIR/certificates/$$PUBLIC_IP.crt" ]; then
        lego --path "$$LEGO_DIR" \
          --email "$$EMAIL" --accept-tos \
          --domains "$$PUBLIC_IP" --disable-cn \
          --http --http.port :80 \
          renew --days 3 --profile shortlived 2>&1 || true
      else
        lego --path "$$LEGO_DIR" \
          --email "$$EMAIL" --accept-tos \
          --domains "$$PUBLIC_IP" --disable-cn \
          --http --http.port :80 \
          run --profile shortlived 2>&1
      fi

      # Copy certs to the expected location
      if [ -f "$$LEGO_DIR/certificates/$$PUBLIC_IP.crt" ]; then
        cp "$$LEGO_DIR/certificates/$$PUBLIC_IP.crt" "$$CERT_DIR/cert.pem"
        cp "$$LEGO_DIR/certificates/$$PUBLIC_IP.key" "$$CERT_DIR/key.pem"
        chmod 600 "$$CERT_DIR/key.pem"
        # Restart web server to pick up new certs
        systemctl restart lobmob-web 2>/dev/null || true
        echo "Certificate issued/renewed for $$PUBLIC_IP"
      else
        echo "WARNING: No certificate found after lego run" >&2
      fi

  # DO OAuth token refresh script -- run by cron every 25 days
  - path: /usr/local/bin/lobmob-refresh-do-token
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      ENV_FILE="/etc/lobmob/secrets.env"
      WEB_ENV="/etc/lobmob/web.env"

      # Load current tokens
      source "$$ENV_FILE"
      source "$$WEB_ENV" 2>/dev/null || true

      REFRESH_TOKEN="$${DO_OAUTH_REFRESH:-}"
      CLIENT_ID="$${DO_OAUTH_CLIENT_ID:-}"
      CLIENT_SECRET="$${DO_OAUTH_CLIENT_SECRET:-}"

      if [ -z "$$REFRESH_TOKEN" ] || [ -z "$$CLIENT_ID" ] || [ -z "$$CLIENT_SECRET" ]; then
        echo "DO OAuth not configured, skipping refresh"
        exit 0
      fi

      RESPONSE=$$(curl -s -X POST "https://cloud.digitalocean.com/v1/oauth/token" \
        -d "grant_type=refresh_token" \
        -d "refresh_token=$$REFRESH_TOKEN" \
        -d "client_id=$$CLIENT_ID" \
        -d "client_secret=$$CLIENT_SECRET")

      ACCESS_TOKEN=$$(echo "$$RESPONSE" | jq -r '.access_token // empty')
      NEW_REFRESH=$$(echo "$$RESPONSE" | jq -r '.refresh_token // empty')

      if [ -z "$$ACCESS_TOKEN" ]; then
        echo "ERROR: Failed to refresh DO token"
        echo "$$RESPONSE"
        lobmob-log error "DO OAuth token refresh failed"
        exit 1
      fi

      # Update tokens in secrets.env
      if grep -q "^DO_OAUTH_TOKEN=" "$$ENV_FILE"; then
        sed -i "s|^DO_OAUTH_TOKEN=.*|DO_OAUTH_TOKEN=$$ACCESS_TOKEN|" "$$ENV_FILE"
      else
        echo "DO_OAUTH_TOKEN=$$ACCESS_TOKEN" >> "$$ENV_FILE"
      fi
      if grep -q "^DO_OAUTH_REFRESH=" "$$ENV_FILE"; then
        sed -i "s|^DO_OAUTH_REFRESH=.*|DO_OAUTH_REFRESH=$$NEW_REFRESH|" "$$ENV_FILE"
      else
        echo "DO_OAUTH_REFRESH=$$NEW_REFRESH" >> "$$ENV_FILE"
      fi

      lobmob-log token-refresh "DO OAuth token refreshed successfully"
      echo "DO OAuth token refreshed"

  # Provision script -- called by `lobmob deploy` via SSH after secrets are pushed
  - path: /usr/local/bin/lobmob-provision
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      echo "=== lobmob provision: configuring lobboss ==="

      # Validate secrets exist
      source /etc/lobmob/secrets.env 2>/dev/null || { echo "ERROR: /etc/lobmob/secrets.env not found"; exit 1; }
      for VAR in DO_TOKEN DISCORD_BOT_TOKEN ANTHROPIC_API_KEY; do
        if [ -z "$${!VAR:-}" ]; then
          echo "ERROR: $$VAR not set in secrets.env"
          exit 1
        fi
      done
      # GH_TOKEN is optional if GitHub App is configured
      if [ -z "$${GH_TOKEN:-}" ] && [ ! -f /etc/lobmob/gh-app.pem ]; then
        echo "ERROR: Neither GH_TOKEN nor GitHub App PEM configured"
        exit 1
      fi

      # Validate deploy key
      if [ ! -f /root/.ssh/vault_key ]; then
        echo "ERROR: /root/.ssh/vault_key not found"
        exit 1
      fi
      chmod 600 /root/.ssh/vault_key

      # Activate WireGuard
      if [ -f /etc/wireguard/wg0.conf ]; then
        wg-quick up wg0 2>/dev/null || true
        systemctl enable wg-quick@wg0
        echo "WireGuard: active"
      else
        echo "ERROR: /etc/wireguard/wg0.conf not found -- was WG private key pushed?"
        exit 1
      fi

      # Authenticate GitHub CLI (prefer App token, fall back to PAT)
      GH_AUTH_TOKEN=""
      if command -v lobmob-gh-token >/dev/null 2>&1; then
        GH_AUTH_TOKEN=$$(lobmob-gh-token 2>/dev/null || true)
      fi
      if [ -z "$$GH_AUTH_TOKEN" ]; then
        GH_AUTH_TOKEN="$$GH_TOKEN"
        echo "GitHub CLI: using PAT"
      else
        echo "GitHub CLI: using App installation token"
      fi
      echo "$$GH_AUTH_TOKEN" | gh auth login --with-token
      gh auth setup-git
      gh config set git_protocol https
      echo "GitHub CLI: authenticated"

      # Re-set git identity (gh auth setup-git clobbers .gitconfig)
      git config --global user.name "lobboss"
      git config --global user.email "lobboss@lobmob.swarm"

      # Authenticate doctl
      doctl auth init -t "$DO_TOKEN"
      echo "doctl: authenticated"

      # Clone vault repo
      source /etc/lobmob/env

      # Look up DO project ID and append to env
      PROJECT_ID=$$(doctl projects list --format ID,Name --no-header | grep "$${PROJECT_NAME}" | awk '{print $$1}')
      if [ -n "$$PROJECT_ID" ]; then
        echo "DO_PROJECT_ID=$$PROJECT_ID" >> /etc/lobmob/env
        echo "DO project: $$PROJECT_ID"
      fi
      if [ ! -d /opt/vault/.git ]; then
        gh repo clone "$VAULT_REPO" /opt/vault
        cd /opt/vault && git checkout main
        echo "Vault: cloned"
      else
        cd /opt/vault && git stash 2>/dev/null || true
        git pull origin main --rebase 2>/dev/null || true
        git stash pop 2>/dev/null || true
        echo "Vault: updated"
      fi

      # Configure OpenClaw
      mkdir -p /root/.openclaw/skills

      # Run openclaw onboard (creates openclaw.json)
      timeout 30 openclaw onboard \
        --non-interactive --accept-risk --workspace /opt/vault 2>/dev/null || true

      # Create .env
      echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" > /root/.openclaw/.env
      chmod 600 /root/.openclaw/.env

      # Ensure openclaw.json exists (fallback if onboard hung)
      if [ ! -f /root/.openclaw/openclaw.json ]; then
        GW_TOKEN=$(openssl rand -hex 24)
        echo "{\"gateway\":{\"port\":18789,\"mode\":\"local\",\"bind\":\"loopback\",\"auth\":{\"mode\":\"token\",\"token\":\"$GW_TOKEN\"}}}" > /root/.openclaw/openclaw.json
      fi

      # Patch openclaw.json with Discord channels + agent config
      # Note: don't include gateway block -- openclaw onboard already sets it with auth token
      jq --arg token "$DISCORD_BOT_TOKEN" '{
        channels: { discord: { enabled: true, token: $token, groupPolicy: "allowlist",
          guilds: { "467002962456084481": { slug: "mattcave", requireMention: false,
            reactionNotifications: "own",
            channels: { "${discord_channels.task_queue}": {allow:true}, "${discord_channels.swarm_control}": {allow:true}, "${discord_channels.swarm_logs}": {allow:true} }
          }}
        }},
        agents: { defaults: { model: { primary: "anthropic/claude-sonnet-4-5" }, workspace: "/opt/vault" }}
      } * .' /root/.openclaw/openclaw.json > /tmp/oc.tmp && mv /tmp/oc.tmp /root/.openclaw/openclaw.json

      # Remove old config.json if it exists
      rm -f /root/.openclaw/config.json

      # Copy lobboss skills and AGENTS.md from vault
      cp -r /opt/vault/040-fleet/lobboss-skills/* /root/.openclaw/skills/ 2>/dev/null || true
      cp /opt/vault/040-fleet/lobboss-AGENTS.md /root/.openclaw/AGENTS.md 2>/dev/null || true

      # Generate SSH keypair for lobboss -> lobster connections
      if [ ! -f /root/.ssh/lobster_admin ]; then
        ssh-keygen -t ed25519 -C "lobboss-to-lobster" -f /root/.ssh/lobster_admin -N "" -q
        echo "SSH keypair for lobster access: generated"
      fi

      # Write systemd service for OpenClaw gateway
      cat > /etc/systemd/system/openclaw-gateway.service <<'SVCEOF'
      [Unit]
      Description=OpenClaw Gateway
      After=network.target wg-quick@wg0.service
      Wants=wg-quick@wg0.service

      [Service]
      Type=simple
      WorkingDirectory=/opt/vault
      EnvironmentFile=/root/.openclaw/.env
      ExecStart=/usr/bin/env openclaw gateway --port 18789
      Restart=on-failure
      RestartSec=10
      StandardOutput=append:/var/log/openclaw-gateway.log
      StandardError=append:/var/log/openclaw-gateway.log

      [Install]
      WantedBy=multi-user.target
      SVCEOF
      systemctl daemon-reload
      systemctl enable openclaw-gateway
      systemctl start openclaw-gateway

      echo "OpenClaw: configured and gateway started"

      # Start web UI if web.env exists (OAuth configured)
      if [ -f /etc/lobmob/web.env ]; then
        systemctl daemon-reload
        systemctl enable lobmob-web
        systemctl start lobmob-web
        echo "Web UI: started on port 8080"

        # Add DO token refresh cron (every 25 days)
        if ! grep -q lobmob-refresh-do-token /etc/crontab 2>/dev/null; then
          echo "0 0 */25 * * root /usr/local/bin/lobmob-refresh-do-token >> /var/log/lobmob-token-refresh.log 2>&1" >> /etc/crontab
        fi
      fi

      # Remove provision marker
      rm -f /etc/lobmob/.awaiting-secrets

      echo "=== lobmob provision: complete ==="

  # Lobster spawn script -- creates droplets with SECRET-FREE cloud-init,
  # then pushes secrets via SSH over WireGuard after boot
  - path: /usr/local/bin/lobmob-spawn-lobster
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      source /etc/lobmob/env
      source /etc/lobmob/secrets.env

      # Name generator ‚Äî lobster-TYPE-NNN-adjective-name
      # ~100 adjectives x ~100 water-themed character names
      _ADJECTIVES=(salty briny bubbly soggy drippy splashy crusty sandy misty foamy breezy stormy slippery barnacled sunken rusty mossy silky shiny drifty tidal murky frothy ancient sunlit moonlit frozen steamy tropical arctic volcanic washed beached stranded marooned anchored capsized listing rolling pitching drifting cruising sailing surfing diving plunging sinking floating bobbing swaying rocking tumbling churning swirling rippling cresting breaking lapping ebbing flowing surging rushing gushing trickling dripping seeping wading paddling rowing sculling trawling tangled knotted braided coiled rigged masted keeled hulled planked craggy pearly abyssal coastal offshore inshore brackish saline brisk gusty balmy humid dewy hazy overcast squalling thundering howling whistling glassy choppy roiling frothing sparkling shimmering glistening gleaming luminous phosphorescent bioluminescent)
      _NAMES=(squidward patrick sandy nemo dory marlin ariel flounder moana maui poseidon triton gilligan skipper wanda finn bubbles coral sheldon neptune aquaman mera namor calypso davy scylla amphitrite oceanus tethys nereus proteus glaucus lorelei undine sedna yemaya ryujin tangaroa ponyo ursula sebastian flotsam jetsam scuttle grimsby eric melody crush squirt bruce anchor chum gill bloat peach jacques gurgle deb nigel gerald hank destiny bailey becky fluke rudder smee hook wendy splash ripley darwin flipper willy shamu echo wahoo barracuda hammerhead stingray nautilus kraken leviathan jaws quint brody hooper ahab ishmael queequeg starbuck pip nessie selkie kelpie morgan drake kelvin marina oceana pearl reef cove fjord atoll lagoon estuary delta shoal caspian baltic coral anemone urchin abalone conch clam mussel oyster scallop starfish)
      _gen_name() {
        local type="$${1:-research}"
        local adj=$${_ADJECTIVES[RANDOM % $${#_ADJECTIVES[@]}]}
        local name=$${_NAMES[RANDOM % $${#_NAMES[@]}]}
        # Find lowest unused number among currently running lobsters
        local existing=$(doctl compute droplet list --tag-name "$${LOBSTER_TAG}" --format Name --no-header 2>/dev/null)
        local num=1
        while echo "$$existing" | grep -q "lobster-$${type}-$(printf "%03d" $$num)-" 2>/dev/null; do
          num=$$((num + 1))
        done
        echo "$${type}-$(printf "%03d" $$num)-$${adj}-$${name}"
      }
      LOBSTER_TYPE="$${3:-research}"
      LOBSTER_ID="$${1:-$$(_gen_name $$LOBSTER_TYPE)}"
      WG_IP="$${2:-}"

      # SWE/QA lobsters need at least 2GB RAM (Opus model + dev tools OOM on 1GB)
      SPAWN_SIZE="$$LOBSTER_SIZE"
      if [ "$$LOBSTER_TYPE" = "swe" ] || [ "$$LOBSTER_TYPE" = "qa" ]; then
        case "$$SPAWN_SIZE" in
          s-1vcpu-1gb) SPAWN_SIZE="s-1vcpu-2gb" ;;
        esac
      fi

      if [ -z "$WG_IP" ]; then
        EXISTING=$(wg show wg0 allowed-ips 2>/dev/null | awk '{print $2}' | cut -d/ -f1 | sort -t. -k4 -n | tail -1)
        LAST_OCTET=$(echo "$${EXISTING:-${wg_subnet}.1}" | cut -d. -f4)
        NEXT_OCTET=$((LAST_OCTET + 1))
        WG_IP="${wg_subnet}.$${NEXT_OCTET}"
      fi

      # Read lobboss SSH public key for injecting into lobster authorized_keys
      LOBBOSS_SSH_PUBKEY=$(cat /root/.ssh/lobster_admin.pub)

      # Generate WireGuard keypair for lobster
      LOBSTER_WG_PRIVKEY=$(wg genkey)
      LOBSTER_WG_PUBKEY=$(echo "$LOBSTER_WG_PRIVKEY" | wg pubkey)
      LOBBOSS_PUB_IP=$(curl -s http://169.254.169.254/metadata/v1/interfaces/public/0/ipv4/address)
      LOBBOSS_WG_PUBKEY=$(wg show wg0 public-key)

      # Build SECRET-FREE cloud-init for lobster
      # Only contains: packages, WireGuard config (ephemeral key -- not a stored secret),
      # SSH authorized keys, git identity, Node.js, OpenClaw, gh CLI install
      LOBSTER_USERDATA=$(cat <<USERDATA
      #!/bin/bash
      set -euo pipefail

      export DEBIAN_FRONTEND=noninteractive
      export HOME=/root
      apt-get update
      apt-get install -y wireguard git jq curl unzip

      # Type-conditional packages
      if [ "$LOBSTER_TYPE" = "swe" ] || [ "$LOBSTER_TYPE" = "qa" ]; then
        apt-get install -y build-essential shellcheck python3-pip
      fi
      if [ "$LOBSTER_TYPE" = "qa" ]; then
        pip3 install pytest --break-system-packages 2>/dev/null || pip3 install pytest
      fi

      # WireGuard -- uses ephemeral keypair generated by lobboss at spawn time
      cat > /etc/wireguard/wg0.conf <<WGEOF
      [Interface]
      PrivateKey = $LOBSTER_WG_PRIVKEY
      Address = $WG_IP/24
      ListenPort = 51820

      [Peer]
      PublicKey = $LOBBOSS_WG_PUBKEY
      AllowedIPs = ${wg_subnet}.0/24
      Endpoint = $LOBBOSS_PUB_IP:51820
      PersistentKeepalive = 25
      WGEOF

      wg-quick up wg0
      systemctl enable wg-quick@wg0

      # SSH authorized keys: DO metadata + lobboss admin key
      mkdir -p /root/.ssh
      curl -s http://169.254.169.254/metadata/v1/public-keys >> /root/.ssh/authorized_keys
      printf '\n%s\n' "$LOBBOSS_SSH_PUBKEY" >> /root/.ssh/authorized_keys

      # Git identity only -- no auth tokens
      git config --global user.name "lobster-$LOBSTER_ID"
      git config --global user.email "lobster-$LOBSTER_ID@lobmob.swarm"

      # Install GitHub CLI (auth happens via lobboss SSH push)
      curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
        | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg 2>/dev/null
      echo "deb [signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
        > /etc/apt/sources.list.d/github-cli.list
      apt-get update && apt-get install -y gh

      # Node.js 22
      curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
      apt-get install -y nodejs

      # OpenClaw (config written later by lobboss via SSH)
      npm install -g openclaw@latest
      mkdir -p /root/.openclaw/skills /etc/lobmob

      # Non-secret config
      cat > /etc/lobmob/env <<ENVEOF
      LOBSTER_ID=$LOBSTER_ID
      WG_IP=$WG_IP
      VAULT_REPO=$VAULT_REPO
      LOBSTER_TYPE=$LOBSTER_TYPE
      ENVEOF

      # Event logger
      cat > /usr/local/bin/lobmob-log <<'LOGEOF'
      #!/bin/bash
      CATEGORY="\$1"; shift
      echo "\$(date -Iseconds) [\$CATEGORY] \$*" >> /var/log/lobmob-events.log
      LOGEOF
      chmod 755 /usr/local/bin/lobmob-log

      # Flush event log to vault
      cat > /usr/local/bin/lobmob-flush-logs <<'FLUSHEOF'
      #!/bin/bash
      set -euo pipefail

      LOG_FILE="/var/log/lobmob-events.log"
      VAULT_DIR="/opt/vault"
      LOCK_FILE="/tmp/lobmob-flush.lock"

      if [ ! -s "\$LOG_FILE" ]; then
        exit 0
      fi

      exec 200>"\$LOCK_FILE"
      flock -n 200 || { echo "Another flush is running"; exit 0; }

      if [ -f /etc/lobmob/env ]; then
        source /etc/lobmob/env
      fi

      if [ -n "\$${LOBSTER_ID:-}" ]; then
        LOG_SUBDIR="020-logs/lobsters/lobster-\$LOBSTER_ID"
        COMMIT_PREFIX="[lobster-\$LOBSTER_ID]"
      else
        LOG_SUBDIR="020-logs/lobboss"
        COMMIT_PREFIX="[lobboss]"
      fi

      TODAY=\$(date +%Y-%m-%d)
      TARGET_FILE="\$VAULT_DIR/\$LOG_SUBDIR/events-\$TODAY.log"

      cd "\$VAULT_DIR"
      git pull origin main --quiet 2>/dev/null || true

      mkdir -p "\$VAULT_DIR/\$LOG_SUBDIR"
      cat "\$LOG_FILE" >> "\$TARGET_FILE"

      git add "\$LOG_SUBDIR/"
      if git diff --cached --quiet; then
        exit 0
      fi

      git commit -m "\$COMMIT_PREFIX Flush event log" --quiet
      git push origin main --quiet

      : > "\$LOG_FILE"
      FLUSHEOF
      chmod 755 /usr/local/bin/lobmob-flush-logs

      # GitHub auth refresh -- regenerate App token and re-auth gh CLI
      cat > /usr/local/bin/lobmob-refresh-gh-auth <<'GHREFRESHEOF'
      #!/bin/bash
      set -euo pipefail
      if [ -f /etc/lobmob/env ]; then source /etc/lobmob/env; fi
      TOKEN=""
      if command -v lobmob-gh-token >/dev/null 2>&1; then
        TOKEN=$$(lobmob-gh-token 2>/dev/null || true)
      fi
      if [ -z "$$TOKEN" ]; then
        if [ -f /etc/lobmob/secrets.env ]; then
          source /etc/lobmob/secrets.env
          TOKEN="$${GH_TOKEN:-}"
        fi
      fi
      if [ -z "$$TOKEN" ]; then
        echo "ERROR: No GitHub token available" >&2
        exit 1
      fi
      echo "$$TOKEN" | gh auth login --with-token 2>/dev/null
      # Re-set git identity (gh auth setup-git clobbers .gitconfig)
      if [ -n "$${LOBSTER_ID:-}" ]; then
        git config --global user.name "lobster-$$LOBSTER_ID"
        git config --global user.email "lobster-$$LOBSTER_ID@lobmob.swarm"
      else
        git config --global user.name "lobboss"
        git config --global user.email "lobboss@lobmob.swarm"
      fi
      echo "$$(date -Iseconds) GitHub auth refreshed"
      GHREFRESHEOF
      chmod 755 /usr/local/bin/lobmob-refresh-gh-auth

      # Flush cron -- every 15 minutes
      echo "*/15 * * * * root /usr/local/bin/lobmob-flush-logs >> /var/log/lobmob-flush.log 2>&1" >> /etc/crontab

      # GitHub auth refresh cron -- every 45 minutes
      echo "*/45 * * * * root /usr/local/bin/lobmob-refresh-gh-auth >> /var/log/lobmob-gh-refresh.log 2>&1" >> /etc/crontab

      # Systemd service for OpenClaw gateway (started after secrets provisioned)
      cat > /etc/systemd/system/openclaw-gateway.service <<'SVCEOF'
      [Unit]
      Description=OpenClaw Gateway
      After=network.target wg-quick@wg0.service
      Wants=wg-quick@wg0.service

      [Service]
      Type=simple
      WorkingDirectory=/opt/vault
      EnvironmentFile=/root/.openclaw/.env
      ExecStart=/usr/bin/env openclaw gateway --port 18789
      Restart=on-failure
      RestartSec=10
      StandardOutput=append:/var/log/openclaw-gateway.log
      StandardError=append:/var/log/openclaw-gateway.log

      [Install]
      WantedBy=multi-user.target
      SVCEOF
      systemctl daemon-reload

      # Signal awaiting secrets
      touch /etc/lobmob/.awaiting-secrets

      # Log boot event
      /usr/local/bin/lobmob-log boot "lobster-$LOBSTER_ID wg_ip=$WG_IP"

      USERDATA
      )

      # Create the droplet
      RESPONSE=$(doctl compute droplet create \
        "lobster-$LOBSTER_ID" \
        --region "$REGION" \
        --size "$SPAWN_SIZE" \
        --image ubuntu-24-04-x64 \
        --ssh-keys "$SSH_KEY_ID" \
        --vpc-uuid "$VPC_UUID" \
        --tag-name "$LOBSTER_TAG,$${LOBSTER_TAG}-type-$${LOBSTER_TYPE}" \
        --user-data "$LOBSTER_USERDATA" \
        --wait \
        --format ID,PublicIPv4 \
        --no-header \
        --output json)

      DROPLET_ID=$(echo "$RESPONSE" | jq -r '.[0].id')
      DROPLET_IP=$(echo "$RESPONSE" | jq -r '.[0].networks.v4[] | select(.type=="public") | .ip_address')

      # Assign lobster to DO project
      if [ -n "$${DO_PROJECT_ID:-}" ]; then
        doctl projects resources assign "$$DO_PROJECT_ID" --resource="do:droplet:$$DROPLET_ID" 2>/dev/null || true
      fi

      # Add lobster as WireGuard peer on lobboss
      wg set wg0 peer "$LOBSTER_WG_PUBKEY" allowed-ips "$WG_IP/32" endpoint "$DROPLET_IP:51820"

      echo "Droplet created. Waiting for WireGuard connectivity..."
      for i in $(seq 1 30); do
        if ping -c 1 -W 2 "$WG_IP" > /dev/null 2>&1; then
          echo "WireGuard: connected to $WG_IP"
          break
        fi
        sleep 5
      done

      # Wait for cloud-init to finish
      echo "Waiting for cloud-init to complete on lobster..."

      # Clear stale known_hosts first (WireGuard IPs get reused across spawns)
      ssh-keygen -f /root/.ssh/known_hosts -R "$WG_IP" 2>/dev/null || true

      # Poll for the .awaiting-secrets marker (last thing cloud-init writes)
      for i in $(seq 1 60); do
        if ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
          "root@$WG_IP" "test -f /etc/lobmob/.awaiting-secrets" 2>/dev/null; then
          echo "Cloud-init: done (marker found after $((i * 5))s)"
          break
        fi
        if [ "$i" -eq 60 ]; then
          echo "WARNING: cloud-init marker not found after 300s, proceeding anyway"
        fi
        sleep 5
      done

      # Push secrets to lobster via SSH over WireGuard
      echo "Pushing secrets to lobster via SSH..."

      # Write secrets.env
      ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" "cat > /etc/lobmob/secrets.env && chmod 600 /etc/lobmob/secrets.env" <<SECRETS
      GH_TOKEN=$GH_TOKEN
      DISCORD_BOT_TOKEN=$DISCORD_BOT_TOKEN
      ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
      SECRETS

      # Push GitHub App PEM and token script if configured
      if [ -f /etc/lobmob/gh-app.pem ]; then
        scp -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new \
          /etc/lobmob/gh-app.pem "root@$WG_IP:/etc/lobmob/gh-app.pem"
        scp -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new \
          /usr/local/bin/lobmob-gh-token "root@$WG_IP:/usr/local/bin/lobmob-gh-token"
        ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" \
          "chmod 600 /etc/lobmob/gh-app.pem && chmod 755 /usr/local/bin/lobmob-gh-token"
        # Push App config to lobster env
        source /etc/lobmob/env
        ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" \
          "echo 'GH_APP_ID=$${GH_APP_ID:-}' >> /etc/lobmob/env; echo 'GH_APP_INSTALL_ID=$${GH_APP_INSTALL_ID:-}' >> /etc/lobmob/env"
      fi

      # Authenticate gh and clone vault
      ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" bash <<PROVISION
      set -euo pipefail
      source /etc/lobmob/secrets.env

      # GitHub auth (prefer App token, fall back to PAT)
      GH_AUTH_TOKEN=""
      if command -v lobmob-gh-token >/dev/null 2>&1; then
        GH_AUTH_TOKEN=\$(lobmob-gh-token 2>/dev/null || true)
      fi
      if [ -z "\$GH_AUTH_TOKEN" ]; then
        GH_AUTH_TOKEN="\$GH_TOKEN"
      fi
      echo "\$GH_AUTH_TOKEN" | gh auth login --with-token
      gh auth setup-git
      gh config set git_protocol https

      # Re-set git identity (gh auth setup-git clobbers .gitconfig)
      git config --global user.name "lobster-$LOBSTER_ID"
      git config --global user.email "lobster-$LOBSTER_ID@lobmob.swarm"

      # Clone vault
      source /etc/lobmob/env
      if [ -d /opt/vault ] && [ ! -d /opt/vault/.git ]; then rm -rf /opt/vault; fi
      gh repo clone "$VAULT_REPO" /opt/vault 2>/dev/null || (cd /opt/vault && git stash 2>/dev/null; git pull origin main --rebase; git stash pop 2>/dev/null || true)
      cd /opt/vault && git checkout main

      # OpenClaw setup -- full automated configuration
      mkdir -p /root/.openclaw/skills

      # Step 1: Run openclaw onboard (creates openclaw.json)
      # May hang over SSH -- timeout + || true handles this
      timeout 30 openclaw onboard \
        --non-interactive --accept-risk --workspace /opt/vault 2>/dev/null || true

      # Step 2: Create .env (API key loaded by gateway via EnvironmentFile)
      echo "ANTHROPIC_API_KEY=\$ANTHROPIC_API_KEY" > /root/.openclaw/.env
      chmod 600 /root/.openclaw/.env

      # Step 3: Ensure openclaw.json exists (fallback if onboard hung)
      if [ ! -f /root/.openclaw/openclaw.json ]; then
        GW_TOKEN=\$(openssl rand -hex 24)
        echo "{\"gateway\":{\"port\":18789,\"mode\":\"local\",\"bind\":\"loopback\",\"auth\":{\"mode\":\"token\",\"token\":\"\$GW_TOKEN\"}}}" > /root/.openclaw/openclaw.json
      fi

      # Step 4: Determine model and AGENTS.md based on lobster type
      source /etc/lobmob/env
      case "\$LOBSTER_TYPE" in
        swe) OC_MODEL="anthropic/claude-opus-4-6"; AGENTS_MODEL="anthropic:claude-opus-4-6-20250918" ;;
        qa)  OC_MODEL="anthropic/claude-sonnet-4-5"; AGENTS_MODEL="anthropic:claude-sonnet-4-5-20250929" ;;
        *)   OC_MODEL="anthropic/claude-sonnet-4-5"; AGENTS_MODEL="anthropic:claude-sonnet-4-5-20250929" ;;
      esac

      # Step 5: Patch openclaw.json with Discord channels + agent config
      # Note: don't include gateway block -- openclaw onboard already sets it with auth token
      jq --arg token "\$DISCORD_BOT_TOKEN" --arg model "\$OC_MODEL" '{
        channels: { discord: { enabled: true, token: \$token, groupPolicy: "allowlist",
          guilds: { "467002962456084481": { slug: "mattcave", requireMention: false,
            reactionNotifications: "own",
            channels: { "${discord_channels.task_queue}": {allow:true}, "${discord_channels.swarm_control}": {allow:true}, "${discord_channels.swarm_logs}": {allow:true} }
          }}
        }},
        agents: { defaults: { model: { primary: \$model }, workspace: "/opt/vault" }}
      } * .' /root/.openclaw/openclaw.json > /tmp/oc.tmp && mv /tmp/oc.tmp /root/.openclaw/openclaw.json

      # Step 6: Remove old config.json if it exists (superseded by openclaw.json)
      rm -f /root/.openclaw/config.json

      # Step 7: Copy lobster skills from vault (type-specific)
      # Base skills (all types)
      for skill in vault-read vault-write submit-results; do
        cp -r "/opt/vault/040-fleet/lobster-skills/\$skill" /root/.openclaw/skills/ 2>/dev/null || true
      done
      # Type-specific skills
      case "\$LOBSTER_TYPE" in
        swe)      cp -r /opt/vault/040-fleet/lobster-skills/code-task /root/.openclaw/skills/ 2>/dev/null || true ;;
        qa)       cp -r /opt/vault/040-fleet/lobster-skills/verify-task /root/.openclaw/skills/ 2>/dev/null || true ;;
        research) cp -r /opt/vault/040-fleet/lobster-skills/task-execute /root/.openclaw/skills/ 2>/dev/null || true ;;
        *)        cp -r /opt/vault/040-fleet/lobster-skills/task-execute /root/.openclaw/skills/ 2>/dev/null || true ;;
      esac

      # Step 8: Clone target repo for SWE/QA lobsters
      if [ "\$LOBSTER_TYPE" = "swe" ] || [ "\$LOBSTER_TYPE" = "qa" ]; then
        gh repo clone minsley/lobmob /opt/lobmob 2>/dev/null || (cd /opt/lobmob && git pull origin develop --rebase 2>/dev/null || true)
        cd /opt/lobmob && git checkout develop 2>/dev/null || git checkout -b develop origin/develop 2>/dev/null || true
      fi

      # Step 9: Write lobster AGENTS.md (metadata only -- system prompt comes from vault)
      cat > /root/.openclaw/AGENTS.md <<AGENTEOF
      ---
      name: lobster-$LOBSTER_ID
      type: $LOBSTER_TYPE
      model: \$AGENTS_MODEL
      ---
      AGENTEOF

      # Step 8: Start gateway via systemd
      systemctl enable openclaw-gateway
      systemctl start openclaw-gateway

      # Mark secrets provisioned
      rm -f /etc/lobmob/.awaiting-secrets
      echo "LOBSTER_READY"
      PROVISION

      echo "Lobster provisioned."

      # Log ready event on the lobster
      ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" \
        "lobmob-log ready lobster-$LOBSTER_ID" 2>/dev/null || true

      # Write config version to lobster for pool management staleness checks
      CONFIG_VERSION=$(md5sum /usr/local/bin/lobmob-spawn-lobster | awk '{print $1}')
      ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" \
        "echo '$CONFIG_VERSION' > /etc/lobmob/config-version"

      lobmob-log spawn "lobster-$LOBSTER_ID type=$LOBSTER_TYPE droplet=$DROPLET_ID wg_ip=$WG_IP"

      # Output lobster info as JSON
      cat <<EOF
      {
        "lobster_id": "lobster-$LOBSTER_ID",
        "type": "$LOBSTER_TYPE",
        "droplet_id": "$DROPLET_ID",
        "public_ip": "$DROPLET_IP",
        "wireguard_ip": "$WG_IP",
        "wg_public_key": "$LOBSTER_WG_PUBKEY"
      }
      EOF

  # Lobster teardown script
  - path: /usr/local/bin/lobmob-teardown-lobster
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      source /etc/lobmob/env
      source /etc/lobmob/secrets.env

      LOBSTER_NAME="$1"

      # Get droplet ID and public IP
      DROPLET_INFO=$(doctl compute droplet list \
        --tag-name "$LOBSTER_TAG" \
        --format ID,Name,PublicIPv4 \
        --no-header | grep "$LOBSTER_NAME")

      DROPLET_ID=$(echo "$DROPLET_INFO" | awk '{print $1}')
      DROPLET_IP=$(echo "$DROPLET_INFO" | awk '{print $3}')

      if [ -z "$DROPLET_ID" ]; then
        echo "Lobster $LOBSTER_NAME not found"
        exit 1
      fi

      # Best-effort: flush lobster's event log before destroy
      WG_IP=$(wg show wg0 allowed-ips 2>/dev/null | while read -r PK ALLOWED; do
        IP=$(echo "$ALLOWED" | cut -d/ -f1)
        REMOTE_ID=$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=3 -o StrictHostKeyChecking=accept-new \
          "root@$IP" "cat /etc/lobmob/env 2>/dev/null | grep LOBSTER_ID | cut -d= -f2" 2>/dev/null || true)
        if echo "$LOBSTER_NAME" | grep -q "$REMOTE_ID" 2>/dev/null && [ -n "$REMOTE_ID" ]; then
          echo "$IP"; break
        fi
      done)
      if [ -n "$WG_IP" ]; then
        ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
          "root@$WG_IP" "lobmob-flush-logs" 2>/dev/null || true
      fi

      # Remove WireGuard peer by matching endpoint IP
      WG_PUBKEY=""
      if [ -n "$DROPLET_IP" ]; then
        WG_PUBKEY=$(wg show wg0 endpoints 2>/dev/null \
          | grep "$DROPLET_IP:" | awk '{print $1}' || true)
      fi
      # Fallback: check vault registry
      if [ -z "$WG_PUBKEY" ]; then
        WG_PUBKEY=$(grep "$LOBSTER_NAME" /opt/vault/040-fleet/registry.md 2>/dev/null \
          | grep -oP 'wg_pubkey: \K\S+' || true)
      fi
      if [ -n "$WG_PUBKEY" ]; then
        wg set wg0 peer "$WG_PUBKEY" remove
        echo "Removed WireGuard peer $WG_PUBKEY"
      fi

      # Destroy droplet
      doctl compute droplet delete "$DROPLET_ID" --force

      lobmob-log destroy "$LOBSTER_NAME droplet=$DROPLET_ID"
      echo "Destroyed $LOBSTER_NAME (droplet $DROPLET_ID)"

  # Fleet status script
  - path: /usr/local/bin/lobmob-fleet-status
    permissions: "0755"
    content: |
      #!/bin/bash
      source /etc/lobmob/env

      POOL_ACTIVE="$${POOL_ACTIVE:-1}"
      POOL_STANDBY="$${POOL_STANDBY:-2}"
      CONFIG_VERSION=$(md5sum /usr/local/bin/lobmob-spawn-lobster 2>/dev/null | awk '{print $1}')

      echo "=== Pool Config ==="
      echo "  POOL_ACTIVE=$POOL_ACTIVE  POOL_STANDBY=$POOL_STANDBY"
      echo "  Config version: $${CONFIG_VERSION:0:8}..."
      echo ""

      echo "=== Lobster Droplets ==="
      DROPLETS=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format ID,Name,PublicIPv4,Status,Created --no-header 2>/dev/null)
      if [ -z "$DROPLETS" ]; then
        echo "  (none)"
      else
        echo "$DROPLETS"
      fi

      # Classify by state
      BUSY=0
      IDLE=0
      STANDBY_COUNT=0
      while read -r ID NAME _ STATUS _; do
        [ -z "$ID" ] && continue
        if [ "$STATUS" = "off" ]; then
          STANDBY_COUNT=$((STANDBY_COUNT + 1))
        elif [ "$STATUS" = "active" ]; then
          LOBSTER_SHORT=$(echo "$NAME" | sed 's/^lobster-//')
          if grep -rl "$LOBSTER_SHORT" /opt/vault/010-tasks/active/ 2>/dev/null | head -1 | grep -q .; then
            BUSY=$((BUSY + 1))
          else
            IDLE=$((IDLE + 1))
          fi
        fi
      done <<< "$DROPLETS"

      echo ""
      echo "=== Pool State ==="
      echo "  active-busy: $BUSY"
      echo "  active-idle: $IDLE (target: $POOL_ACTIVE)"
      echo "  standby:     $STANDBY_COUNT (target: $POOL_STANDBY)"
      echo ""

      echo "=== WireGuard Peers ==="
      wg show wg0

      echo ""
      echo "=== Open PRs ==="
      cd /opt/vault && gh pr list --state open --json number,title,headRefName,author,createdAt 2>/dev/null || echo "No vault repo"

  # Pool-aware cleanup (replaces age-based cleanup)
  - path: /usr/local/bin/lobmob-cleanup
    permissions: "0755"
    content: |
      #!/bin/bash
      source /etc/lobmob/env
      source /etc/lobmob/secrets.env 2>/dev/null || true

      POOL_ACTIVE="$${POOL_ACTIVE:-1}"
      POOL_STANDBY="$${POOL_STANDBY:-2}"
      HARD_MAX_HOURS=24
      NOW=$(date +%s)

      # Get all lobster droplets
      DROPLETS=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format ID,Name,Status,Created --no-header 2>/dev/null)
      if [ -z "$DROPLETS" ]; then
        exit 0
      fi

      # Classify droplets
      ACTIVE_IDLE=()
      STANDBY=()
      SLEPT=0
      DESTROYED=0
      AGED_OUT=0

      while read -r ID NAME STATUS CREATED; do
        # Hard ceiling: destroy ANY lobster older than 24h
        CREATED_TS=$(date -d "$CREATED" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED" +%s 2>/dev/null)
        AGE_HOURS=$(( (NOW - CREATED_TS) / 3600 ))
        if [ "$AGE_HOURS" -ge "$HARD_MAX_HOURS" ]; then
          echo "Destroying lobster $NAME (age: $${AGE_HOURS}h exceeds $${HARD_MAX_HOURS}h ceiling)"
          lobmob-teardown-lobster "$NAME"
          AGED_OUT=$((AGED_OUT + 1))
          continue
        fi

        if [ "$STATUS" = "off" ]; then
          STANDBY+=("$NAME")
        elif [ "$STATUS" = "active" ]; then
          # Skip lobsters still setting up (no config-version = spawn incomplete)
          WG_IP=$(wg show wg0 allowed-ips 2>/dev/null | while read -r PK ALLOWED; do
            IP=$$(echo "$$ALLOWED" | cut -d/ -f1)
            RID=$$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=2 -o BatchMode=yes \
              "root@$$IP" "cat /etc/lobmob/env 2>/dev/null | grep LOBSTER_ID | cut -d= -f2" 2>/dev/null || true)
            if echo "$$NAME" | grep -q "$$RID" 2>/dev/null && [ -n "$$RID" ]; then echo "$$IP"; break; fi
          done)
          if [ -n "$$WG_IP" ]; then
            READY=$$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=2 -o BatchMode=yes \
              "root@$$WG_IP" "test -f /etc/lobmob/config-version && echo yes || echo no" 2>/dev/null || echo "no")
            if [ "$$READY" != "yes" ]; then
              echo "Skipping $NAME (still provisioning)"
              continue
            fi
          else
            echo "Skipping $NAME (not reachable over WG ‚Äî likely still booting)"
            continue
          fi

          # Check if busy (has active task in vault)
          BUSY=0
          if ls /opt/vault/010-tasks/active/*"$NAME"* 2>/dev/null | grep -q .; then
            BUSY=1
          fi
          if [ "$BUSY" -eq 0 ]; then
            ACTIVE_IDLE+=("$NAME")
          fi
        fi
      done <<< "$DROPLETS"

      # Sleep excess idle lobsters beyond POOL_ACTIVE
      IDLE_COUNT=$${#ACTIVE_IDLE[@]}
      if [ "$IDLE_COUNT" -gt "$POOL_ACTIVE" ]; then
        EXCESS=$(( IDLE_COUNT - POOL_ACTIVE ))
        echo "Sleeping $EXCESS excess idle lobsters (have $IDLE_COUNT, want $POOL_ACTIVE)"
        for (( i=0; i<EXCESS; i++ )); do
          lobmob-sleep-lobster "$${ACTIVE_IDLE[$i]}"
          SLEPT=$((SLEPT + 1))
        done
      fi

      # Destroy excess standby lobsters beyond POOL_STANDBY
      STANDBY_COUNT=$${#STANDBY[@]}
      if [ "$STANDBY_COUNT" -gt "$POOL_STANDBY" ]; then
        EXCESS=$(( STANDBY_COUNT - POOL_STANDBY ))
        echo "Destroying $EXCESS excess standby lobsters (have $STANDBY_COUNT, want $POOL_STANDBY)"
        for (( i=0; i<EXCESS; i++ )); do
          lobmob-teardown-lobster "$${STANDBY[$i]}"
          DESTROYED=$((DESTROYED + 1))
        done
      fi

      lobmob-log cleanup "slept=$SLEPT destroyed=$DESTROYED aged_out=$AGED_OUT"

  # Sleep lobster script -- powers off a lobster, preserving disk
  - path: /usr/local/bin/lobmob-sleep-lobster
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      source /etc/lobmob/env

      LOBSTER_NAME="$1"

      # Look up droplet ID
      DROPLET_ID=$(doctl compute droplet list \
        --tag-name "$LOBSTER_TAG" \
        --format ID,Name \
        --no-header | grep "$LOBSTER_NAME" | awk '{print $1}')

      if [ -z "$DROPLET_ID" ]; then
        echo "Lobster $LOBSTER_NAME not found"
        exit 1
      fi

      echo "Sleeping $LOBSTER_NAME (droplet $DROPLET_ID)..."

      # Flush lobster's event log before sleep
      # Find WG IP by checking peers
      WG_IP=$(wg show wg0 allowed-ips 2>/dev/null | while read -r PK ALLOWED; do
        IP=$(echo "$ALLOWED" | cut -d/ -f1)
        REMOTE_ID=$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=3 -o StrictHostKeyChecking=accept-new \
          "root@$IP" "cat /etc/lobmob/env 2>/dev/null | grep LOBSTER_ID | cut -d= -f2" 2>/dev/null || true)
        if echo "$LOBSTER_NAME" | grep -q "$REMOTE_ID" 2>/dev/null && [ -n "$REMOTE_ID" ]; then
          echo "$IP"; break
        fi
      done)
      if [ -n "$WG_IP" ]; then
        ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
          "root@$WG_IP" "lobmob-flush-logs" 2>/dev/null || true
      fi

      # Graceful shutdown with timeout
      doctl compute droplet-action shutdown "$DROPLET_ID" --wait 2>/dev/null &
      SHUTDOWN_PID=$!
      TIMEOUT=120
      ELAPSED=0
      while kill -0 "$SHUTDOWN_PID" 2>/dev/null; do
        sleep 5
        ELAPSED=$((ELAPSED + 5))
        if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
          kill "$SHUTDOWN_PID" 2>/dev/null || true
          echo "Graceful shutdown timed out, forcing power-off..."
          doctl compute droplet-action power-off "$DROPLET_ID" --wait
          break
        fi
      done
      wait "$SHUTDOWN_PID" 2>/dev/null || true

      lobmob-log sleep "$LOBSTER_NAME droplet=$DROPLET_ID"
      echo "Lobster $LOBSTER_NAME is now standby (powered off)"

  # Wake lobster script -- powers on a standby lobster
  - path: /usr/local/bin/lobmob-wake-lobster
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      source /etc/lobmob/env
      source /etc/lobmob/secrets.env

      LOBSTER_NAME="$1"

      # Look up droplet info
      DROPLET_INFO=$(doctl compute droplet list \
        --tag-name "$LOBSTER_TAG" \
        --format ID,Name,Status \
        --no-header | grep "$LOBSTER_NAME")

      if [ -z "$DROPLET_INFO" ]; then
        echo "Lobster $LOBSTER_NAME not found"
        exit 1
      fi

      DROPLET_ID=$(echo "$DROPLET_INFO" | awk '{print $1}')
      DROPLET_STATUS=$(echo "$DROPLET_INFO" | awk '{print $3}')

      if [ "$DROPLET_STATUS" = "active" ]; then
        echo "Lobster $LOBSTER_NAME is already active"
        exit 0
      fi

      echo "Waking $LOBSTER_NAME (droplet $DROPLET_ID)..."
      doctl compute droplet-action power-on "$DROPLET_ID" --wait

      # Look up WG IP from wg show (the peer config survives power cycle)
      WG_IP=""
      while read -r PUBKEY ALLOWED; do
        IP=$(echo "$ALLOWED" | cut -d/ -f1)
        # Try to match -- we'll ping all peers and see which comes alive
        if ping -c 1 -W 2 "$IP" > /dev/null 2>&1; then
          # Verify it's our lobster by SSHing in
          REMOTE_NAME=$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
            "root@$IP" "cat /etc/lobmob/env 2>/dev/null | grep LOBSTER_ID | cut -d= -f2" 2>/dev/null || true)
          if echo "$LOBSTER_NAME" | grep -q "$REMOTE_NAME" 2>/dev/null && [ -n "$REMOTE_NAME" ]; then
            WG_IP="$IP"
            break
          fi
        fi
      done < <(wg show wg0 allowed-ips 2>/dev/null)

      # If no WG IP found via matching, scan all peers for connectivity
      if [ -z "$WG_IP" ]; then
        echo "Waiting for WireGuard connectivity..."
        for attempt in $(seq 1 30); do
          while read -r PUBKEY ALLOWED; do
            IP=$(echo "$ALLOWED" | cut -d/ -f1)
            if ping -c 1 -W 2 "$IP" > /dev/null 2>&1; then
              REMOTE_NAME=$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
                "root@$IP" "cat /etc/lobmob/env 2>/dev/null | grep LOBSTER_ID | cut -d= -f2" 2>/dev/null || true)
              if echo "$LOBSTER_NAME" | grep -q "$REMOTE_NAME" 2>/dev/null && [ -n "$REMOTE_NAME" ]; then
                WG_IP="$IP"
                break 2
              fi
            fi
          done < <(wg show wg0 allowed-ips 2>/dev/null)
          sleep 5
        done
      fi

      if [ -z "$WG_IP" ]; then
        echo "ERROR: Could not establish WireGuard connectivity to $LOBSTER_NAME"
        exit 1
      fi

      echo "WireGuard: connected at $WG_IP"

      # Wait for SSH
      echo "Waiting for SSH..."
      for i in $(seq 1 12); do
        if ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
          "root@$WG_IP" "true" 2>/dev/null; then
          break
        fi
        sleep 5
      done

      # Pull latest vault
      ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" \
        "cd /opt/vault && git pull origin main" 2>/dev/null || true

      # Refresh secrets
      ssh -i /root/.ssh/lobster_admin -o StrictHostKeyChecking=accept-new "root@$WG_IP" \
        "cat > /etc/lobmob/secrets.env && chmod 600 /etc/lobmob/secrets.env" <<SECRETS
      GH_TOKEN=$GH_TOKEN
      DISCORD_BOT_TOKEN=$DISCORD_BOT_TOKEN
      ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
      SECRETS

      lobmob-log wake "$LOBSTER_NAME wg_ip=$WG_IP"
      echo "Lobster $LOBSTER_NAME is awake at $WG_IP"

      # Output lobster info as JSON
      cat <<EOF
      {
        "lobster_name": "$LOBSTER_NAME",
        "droplet_id": "$DROPLET_ID",
        "wireguard_ip": "$WG_IP",
        "status": "active"
      }
      EOF

  # Pool manager -- reconciliation loop for the lobster pool
  - path: /usr/local/bin/lobmob-pool-manager
    permissions: "0755"
    content: |
      #!/bin/bash
      source /etc/lobmob/env
      source /etc/lobmob/secrets.env 2>/dev/null || true

      POOL_ACTIVE="$${POOL_ACTIVE:-1}"
      POOL_STANDBY="$${POOL_STANDBY:-2}"
      MAX_LOBSTERS=10

      echo "$(date -Iseconds) Pool manager: target active-idle=$POOL_ACTIVE standby=$POOL_STANDBY"

      # Get all lobster droplets
      DROPLETS=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format ID,Name,Status --no-header 2>/dev/null)

      ACTIVE_BUSY=()
      ACTIVE_IDLE=()
      STANDBY=()
      TOTAL=0

      # Pull vault once for task checks
      cd /opt/vault 2>/dev/null && git pull origin main --quiet 2>/dev/null || true

      while read -r ID NAME STATUS; do
        [ -z "$ID" ] && continue
        TOTAL=$((TOTAL + 1))
        if [ "$STATUS" = "off" ]; then
          STANDBY+=("$NAME")
        elif [ "$STATUS" = "active" ]; then
          # Skip lobsters still setting up (no config-version = spawn incomplete)
          # Use ping + SSH to check readiness without scanning all WG peers
          LOBSTER_READY=0
          LOBSTER_SHORT=$$(echo "$$NAME" | sed 's/^lobster-//')
          for PEER_IP in $$(wg show wg0 allowed-ips 2>/dev/null | awk '{print $$2}' | cut -d/ -f1); do
            RID=$$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=2 -o BatchMode=yes \
              "root@$$PEER_IP" "cat /etc/lobmob/env 2>/dev/null | grep LOBSTER_ID | cut -d= -f2" 2>/dev/null || true)
            if [ -n "$$RID" ] && echo "$$NAME" | grep -q "$$RID"; then
              if ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=2 -o BatchMode=yes \
                "root@$$PEER_IP" "test -f /etc/lobmob/config-version" 2>/dev/null; then
                LOBSTER_READY=1
              fi
              break
            fi
          done
          if [ "$$LOBSTER_READY" -eq 0 ]; then
            echo "  Skipping $$NAME (still provisioning or unreachable)"
            continue
          fi

          # Check if lobster is busy (assigned to an active task in vault)
          BUSY=0
          if grep -rl "$$LOBSTER_SHORT" /opt/vault/010-tasks/active/ 2>/dev/null | head -1 | grep -q .; then
            BUSY=1
          fi
          if [ "$$BUSY" -eq 1 ]; then
            ACTIVE_BUSY+=("$$NAME")
          else
            ACTIVE_IDLE+=("$$NAME")
          fi
        fi
      done <<< "$$DROPLETS"

      BUSY_COUNT=$${#ACTIVE_BUSY[@]}
      IDLE_COUNT=$${#ACTIVE_IDLE[@]}
      STANDBY_COUNT=$${#STANDBY[@]}

      echo "  Current: active-busy=$BUSY_COUNT active-idle=$IDLE_COUNT standby=$STANDBY_COUNT total=$TOTAL"

      # Current config version
      CONFIG_VERSION=$(md5sum /usr/local/bin/lobmob-spawn-lobster 2>/dev/null | awk '{print $1}')

      # Step 1: Destroy stale standby lobsters (config version mismatch)
      for NAME in "$${STANDBY[@]}"; do
        # Power on briefly to check? No -- too expensive. Check via doctl tags or stored metadata.
        # Instead, wake and check, or just track version at sleep time.
        # For now, we store config version on the lobster at spawn time and check via SSH after wake.
        # Stale detection happens during wake: if version mismatches, teardown instead.
        true
      done

      # Step 2: Need more idle active?
      if [ "$IDLE_COUNT" -lt "$POOL_ACTIVE" ]; then
        NEED=$((POOL_ACTIVE - IDLE_COUNT))
        echo "  Need $NEED more active-idle lobsters"

        for (( i=0; i<NEED; i++ )); do
          if [ "$TOTAL" -ge "$MAX_LOBSTERS" ]; then
            echo "  Hit max lobster limit ($MAX_LOBSTERS), skipping"
            break
          fi

          # Prefer waking standby over spawning new
          if [ "$STANDBY_COUNT" -gt 0 ]; then
            WAKE_NAME="$${STANDBY[0]}"
            echo "  Waking standby lobster: $WAKE_NAME"
            RESULT=$(lobmob-wake-lobster "$WAKE_NAME" 2>&1) || true
            echo "$RESULT"

            # Check config version after wake
            WG_IP=$(echo "$RESULT" | grep -oP '"wireguard_ip": "\K[^"]+' || true)
            if [ -n "$WG_IP" ]; then
              REMOTE_VERSION=$(ssh -i /root/.ssh/lobster_admin -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
                "root@$WG_IP" "cat /etc/lobmob/config-version 2>/dev/null" 2>/dev/null || true)
              if [ -n "$REMOTE_VERSION" ] && [ "$REMOTE_VERSION" != "$CONFIG_VERSION" ]; then
                echo "  Config version mismatch on $WAKE_NAME (got $REMOTE_VERSION, want $CONFIG_VERSION) -- destroying and spawning fresh"
                lobmob-teardown-lobster "$WAKE_NAME"
                lobmob-spawn-lobster
                TOTAL=$((TOTAL))  # net zero: destroyed one, spawned one
              fi
            fi

            # Remove from standby array
            STANDBY=("$${STANDBY[@]:1}")
            STANDBY_COUNT=$${#STANDBY[@]}
          else
            echo "  No standby available, spawning new lobster"
            lobmob-spawn-lobster
            TOTAL=$((TOTAL + 1))
          fi
        done
      fi

      # Step 3: Too many idle active? Sleep excess.
      if [ "$IDLE_COUNT" -gt "$POOL_ACTIVE" ]; then
        EXCESS=$((IDLE_COUNT - POOL_ACTIVE))
        echo "  Sleeping $EXCESS excess idle lobsters"
        for (( i=0; i<EXCESS; i++ )); do
          lobmob-sleep-lobster "$${ACTIVE_IDLE[$i]}"
        done
      fi

      # Step 4: Too many standby? Destroy excess.
      # Re-count standby (may have changed from waking)
      STANDBY_NOW=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format Name,Status --no-header 2>/dev/null \
        | awk '$2 == "off" {print $1}')
      STANDBY_COUNT_NOW=$(echo "$STANDBY_NOW" | grep -c . 2>/dev/null || echo 0)
      if [ "$STANDBY_COUNT_NOW" -gt "$POOL_STANDBY" ]; then
        EXCESS=$((STANDBY_COUNT_NOW - POOL_STANDBY))
        echo "  Destroying $EXCESS excess standby lobsters"
        echo "$STANDBY_NOW" | head -n "$EXCESS" | while read -r NAME; do
          lobmob-teardown-lobster "$NAME"
        done
      fi

      # Step 5: Pool underfilled? Spawn to fill.
      # Re-count everything
      CURRENT_IDLE=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format Name,Status --no-header 2>/dev/null \
        | awk '$2 == "active" {print $1}' | wc -l)
      CURRENT_STANDBY=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format Name,Status --no-header 2>/dev/null \
        | awk '$2 == "off" {print $1}' | wc -l)
      CURRENT_TOTAL=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format ID --no-header 2>/dev/null | wc -l)
      POOL_TARGET=$((POOL_ACTIVE + POOL_STANDBY))
      AVAILABLE=$((CURRENT_IDLE + CURRENT_STANDBY - BUSY_COUNT))
      if [ "$AVAILABLE" -lt "$POOL_TARGET" ] && [ "$CURRENT_TOTAL" -lt "$MAX_LOBSTERS" ]; then
        NEED=$((POOL_TARGET - AVAILABLE))
        CAPACITY=$((MAX_LOBSTERS - CURRENT_TOTAL))
        SPAWN=$(( NEED < CAPACITY ? NEED : CAPACITY ))
        echo "  Pool underfilled (available=$AVAILABLE, target=$POOL_TARGET). Spawning $SPAWN lobsters."
        for (( i=0; i<SPAWN; i++ )); do
          lobmob-spawn-lobster
        done
      fi

      # Log convergence result
      FINAL_ACTIVE=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format Status --no-header 2>/dev/null \
        | grep -c "active" || echo 0)
      FINAL_STANDBY=$(doctl compute droplet list --tag-name "$LOBSTER_TAG" --format Status --no-header 2>/dev/null \
        | grep -c "off" || echo 0)
      FINAL_TOTAL=$((FINAL_ACTIVE + FINAL_STANDBY))
      lobmob-log converge "active=$FINAL_ACTIVE standby=$FINAL_STANDBY total=$FINAL_TOTAL"

      echo "$(date -Iseconds) Pool manager: done"

  # PR review script
  - path: /usr/local/bin/lobmob-review-prs
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      source /etc/lobmob/env
      cd /opt/vault

      git checkout main && git pull origin main

      PRS=$(gh pr list --state open --json number,title,headRefName --jq '.[]' 2>/dev/null)
      if [ -z "$PRS" ]; then
        exit 0
      fi

      echo "$PRS" | jq -c '.' | while read -r PR; do
        NUMBER=$(echo "$PR" | jq -r '.number')
        TITLE=$(echo "$PR" | jq -r '.title')
        BRANCH=$(echo "$PR" | jq -r '.headRefName')

        echo "Reviewing PR #$NUMBER: $TITLE ($BRANCH)"

        # Check diff for secrets
        DIFF=$(gh pr diff "$NUMBER" 2>/dev/null || true)
        if echo "$DIFF" | grep -qiE '(sk-ant-|dop_v1_|github_pat_|PRIVATE KEY)'; then
          gh pr comment "$NUMBER" --body "Possible secrets detected in diff. Please remove and force-push."
          echo "BLOCKED PR #$NUMBER -- secrets detected"
          continue
        fi

        # Check file paths are within allowed directories
        FILES=$(gh pr view "$NUMBER" --json files --jq '.files[].path')
        INVALID=$(echo "$FILES" | grep -vE '^(010-tasks/|020-logs/|030-knowledge/|000-inbox/)' || true)
        if [ -n "$INVALID" ]; then
          gh pr comment "$NUMBER" --body "Files outside allowed paths: $INVALID"
          echo "BLOCKED PR #$NUMBER -- invalid paths"
          continue
        fi

        echo "PR #$NUMBER passes checks -- ready for lobboss agent review"
      done

  # Event logger -- appends timestamped lines to /var/log/lobmob-events.log
  - path: /usr/local/bin/lobmob-log
    permissions: "0755"
    content: |
      #!/bin/bash
      CATEGORY="$1"; shift
      echo "$(date -Iseconds) [$CATEGORY] $*" >> /var/log/lobmob-events.log

  # Flush event log to vault and push
  - path: /usr/local/bin/lobmob-flush-logs
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      LOG_FILE="/var/log/lobmob-events.log"
      VAULT_DIR="/opt/vault"
      LOCK_FILE="/tmp/lobmob-flush.lock"

      # Nothing to flush
      if [ ! -s "$LOG_FILE" ]; then
        exit 0
      fi

      exec 200>"$LOCK_FILE"
      flock -n 200 || { echo "Another flush is running"; exit 0; }

      # Determine identity
      if [ -f /etc/lobmob/env ]; then
        source /etc/lobmob/env
      fi

      if [ -n "$${LOBSTER_ID:-}" ]; then
        LOG_SUBDIR="020-logs/lobsters/lobster-$LOBSTER_ID"
        COMMIT_PREFIX="[lobster-$LOBSTER_ID]"
      else
        LOG_SUBDIR="020-logs/lobboss"
        COMMIT_PREFIX="[lobboss]"
      fi

      TODAY=$(date +%Y-%m-%d)
      TARGET_FILE="$VAULT_DIR/$LOG_SUBDIR/events-$TODAY.log"

      cd "$VAULT_DIR"
      git pull origin main --quiet 2>/dev/null || true

      mkdir -p "$VAULT_DIR/$LOG_SUBDIR"
      cat "$LOG_FILE" >> "$TARGET_FILE"

      git add "$LOG_SUBDIR/"
      if git diff --cached --quiet; then
        exit 0
      fi

      git commit -m "$COMMIT_PREFIX Flush event log" --quiet
      git push origin main --quiet

      # Truncate local log on success
      : > "$LOG_FILE"

  # Weekly snapshot of lobboss droplet for disaster recovery
  - path: /usr/local/bin/lobmob-snapshot
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      source /etc/lobmob/env
      source /etc/lobmob/secrets.env

      SNAPSHOT_NAME="lobboss-$$(date +%Y%m%d-%H%M)"
      MAX_SNAPSHOTS=4

      # Get lobboss droplet ID from DO metadata
      DROPLET_ID=$$(curl -s http://169.254.169.254/metadata/v1/id)
      if [ -z "$$DROPLET_ID" ]; then
        echo "ERROR: Could not get droplet ID from metadata"
        exit 1
      fi

      echo "Creating snapshot: $$SNAPSHOT_NAME for droplet $$DROPLET_ID"
      doctl compute droplet-action snapshot "$$DROPLET_ID" \
        --snapshot-name "$$SNAPSHOT_NAME" --wait 2>&1

      echo "Snapshot created: $$SNAPSHOT_NAME"
      lobmob-log snapshot "$$SNAPSHOT_NAME droplet=$$DROPLET_ID"

      # Prune old snapshots (keep only MAX_SNAPSHOTS most recent)
      SNAPSHOTS=$$(doctl compute snapshot list \
        --resource droplet \
        --format ID,Name,CreatedAt \
        --no-header 2>/dev/null \
        | grep "lobboss-" \
        | sort -k3 -r)

      COUNT=0
      echo "$$SNAPSHOTS" | while read -r snap_id snap_name snap_date rest; do
        COUNT=$$((COUNT + 1))
        if [ $$COUNT -gt $$MAX_SNAPSHOTS ]; then
          echo "Pruning old snapshot: $$snap_name ($$snap_id)"
          doctl compute snapshot delete "$$snap_id" --force 2>/dev/null || true
        fi
      done

  # Task status watcher ‚Äî polls task files for changes and posts Discord updates
  # Eliminates the need for lobsters to post routine status updates via LLM
  - path: /usr/local/bin/lobmob-task-watcher
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail
      VAULT_DIR="/opt/vault"
      STATE_DIR="/var/lib/lobmob/task-state"
      LOG="/var/log/lobmob-task-watcher.log"
      mkdir -p "$$STATE_DIR"

      # Pull latest vault
      cd "$$VAULT_DIR" && git pull origin main --quiet 2>/dev/null || true

      # Check each active task file for status changes
      for task_file in "$$VAULT_DIR"/010-tasks/active/*.md; do
        [ -f "$$task_file" ] || continue
        task_id=$$(basename "$$task_file" .md)
        state_file="$$STATE_DIR/$${task_id}.state"

        # Extract key frontmatter fields
        status=$$(grep "^status:" "$$task_file" | head -1 | awk '{print $$2}')
        assigned=$$(grep "^assigned_to:" "$$task_file" | head -1 | sed 's/assigned_to: *//')
        thread_id=$$(grep "^discord_thread_id:" "$$task_file" | head -1 | awk '{print $$2}')

        # Build current state string
        current="status=$$status assigned=$$assigned"

        # Compare with last known state
        previous=""
        if [ -f "$$state_file" ]; then
          previous=$$(cat "$$state_file")
        fi

        if [ "$$current" != "$$previous" ]; then
          echo "$$current" > "$$state_file"

          # Skip if no thread_id (can't post to Discord without it)
          if [ -z "$$thread_id" ]; then continue; fi

          # Determine what changed and compose message
          msg=""
          prev_status=$$(echo "$$previous" | grep -o 'status=[^ ]*' | cut -d= -f2)
          prev_assigned=$$(echo "$$previous" | grep -o 'assigned=[^ ]*' | cut -d= -f2)

          if [ "$$status" = "active" ] && [ "$$prev_status" != "active" ] && [ -n "$$assigned" ]; then
            msg="Task **$$task_id** assigned to **$$assigned**"
          elif [ "$$status" = "completed" ] && [ "$$prev_status" != "completed" ]; then
            msg="Task **$$task_id** completed by **$$assigned**"
          elif [ "$$status" = "failed" ] && [ "$$prev_status" != "failed" ]; then
            msg="Task **$$task_id** failed (assigned to **$$assigned**)"
          elif [ "$$status" = "queued" ] && [ "$$prev_status" = "active" ]; then
            msg="Task **$$task_id** re-queued"
          fi

          if [ -n "$$msg" ]; then
            echo "$$(date -Iseconds) $$msg" >> "$$LOG"
            # Post to Discord thread via OpenClaw gateway API
            GW_TOKEN=$$(jq -r '.gateway.auth.token // empty' /root/.openclaw/openclaw.json 2>/dev/null)
            if [ -n "$$GW_TOKEN" ]; then
              curl -s -X POST "http://127.0.0.1:18789/api/channels/discord/send" \
                -H "Authorization: Bearer $$GW_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"threadId\": \"$$thread_id\", \"content\": \"$$msg\"}" 2>/dev/null || true
            fi
          fi
        fi
      done

      # Also check for completed/failed tasks that should be moved
      for task_file in "$$VAULT_DIR"/010-tasks/active/*.md; do
        [ -f "$$task_file" ] || continue
        status=$$(grep "^status:" "$$task_file" | head -1 | awk '{print $$2}')
        if [ "$$status" = "completed" ] || [ "$$status" = "failed" ]; then
          task_id=$$(basename "$$task_file" .md)
          dest="$$VAULT_DIR/010-tasks/$$status/$$task_id.md"
          if [ ! -f "$$dest" ]; then
            mv "$$task_file" "$$dest"
            cd "$$VAULT_DIR" && git add -A && git commit -m "[task-watcher] Move $$task_id to $$status" --quiet 2>/dev/null
            git push origin main --quiet 2>/dev/null || true
            rm -f "$$STATE_DIR/$${task_id}.state"
            echo "$$(date -Iseconds) Moved $$task_id to $$status" >> "$$LOG"
          fi
        fi
      done

  # Awaiting secrets marker
  - path: /etc/lobmob/.awaiting-secrets
    content: "Secrets not yet provisioned. Run: lobmob deploy\n"

runcmd:
  # Install GitHub CLI (auth happens later via provision script)
  - curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg 2>/dev/null
  - echo "deb [signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" > /etc/apt/sources.list.d/github-cli.list
  - apt-get update && apt-get install -y gh

  # Install doctl (auth happens later via provision script)
  - snap install doctl

  # Install Node.js 22
  - curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
  - apt-get install -y nodejs

  # Install OpenClaw (config written later via provision script)
  - npm install -g openclaw@latest
  - mkdir -p /root/.openclaw/skills

  # Git identity only -- no auth
  - git config --global user.name "lobboss"
  - git config --global user.email "lobboss@lobmob.swarm"

  # Pool manager cron -- every 5 minutes
  - echo "*/5 * * * * root /usr/local/bin/lobmob-pool-manager >> /var/log/lobmob-pool-manager.log 2>&1" >> /etc/crontab

  # PR review cron -- every 2 minutes
  - echo "*/2 * * * * root /usr/local/bin/lobmob-review-prs >> /var/log/lobmob-pr-review.log 2>&1" >> /etc/crontab

  # Event log flush cron -- every 15 minutes
  - echo "*/15 * * * * root /usr/local/bin/lobmob-flush-logs >> /var/log/lobmob-flush.log 2>&1" >> /etc/crontab

  # GitHub auth refresh cron -- every 45 minutes
  - echo "*/45 * * * * root /usr/local/bin/lobmob-refresh-gh-auth >> /var/log/lobmob-gh-refresh.log 2>&1" >> /etc/crontab

  # TLS cert renewal cron -- every 4 days (certs last 6 days)
  - echo "0 3 */4 * * root /usr/local/bin/lobmob-cert >> /var/log/lobmob-cert.log 2>&1" >> /etc/crontab

  # Task status watcher -- every 2 minutes (detects task changes, posts to Discord, moves completed tasks)
  - echo "*/2 * * * * root /usr/local/bin/lobmob-task-watcher >> /var/log/lobmob-task-watcher.log 2>&1" >> /etc/crontab

  # Weekly snapshot of lobboss (prod only, requires doctl auth)
  - echo "0 4 * * 0 root /usr/local/bin/lobmob-snapshot >> /var/log/lobmob-snapshot.log 2>&1" >> /etc/crontab


#!/bin/bash
# await-task-pickup — poll vault until lobboss assigns queued tasks and spawns lobsters
# Usage: await-task-pickup [--timeout <minutes>] <task-id> [task-id...]
#
# Watches the vault repo for each task's frontmatter to change:
#   status: queued  →  status: active
#   assigned_to:    →  assigned_to: lobster-<id>
# Then confirms the assigned lobster droplet exists in the fleet.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
INFRA_DIR="$PROJECT_DIR/infra"
VAULT_LOCAL="$PROJECT_DIR/vault-local"
LOBMOB_SSH_KEY="$HOME/.ssh/lobmob_ed25519"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

lobmob_ssh() {
  ssh -i "$LOBMOB_SSH_KEY" -o StrictHostKeyChecking=accept-new "$@"
}

get_lobboss_ip() {
  terraform -chdir="$INFRA_DIR" output -raw lobboss_ip 2>/dev/null
}

# --- Parse arguments ---

TIMEOUT_MINUTES=10
TASK_IDS=()

while [ $# -gt 0 ]; do
  case "$1" in
    --timeout) TIMEOUT_MINUTES="$2"; shift 2 ;;
    --help|-h) echo "Usage: await-task-pickup [--timeout <minutes>] <task-id> [task-id...]"; exit 0 ;;
    *) TASK_IDS+=("$1"); shift ;;
  esac
done

if [ ${#TASK_IDS[@]} -eq 0 ]; then
  echo "Usage: await-task-pickup [--timeout <minutes>] <task-id> [task-id...]"
  exit 1
fi

# --- Preflight ---

VAULT_REPO=$(grep vault_repo "$INFRA_DIR/terraform.tfvars" 2>/dev/null | cut -d'"' -f2)
if [ -z "$VAULT_REPO" ]; then
  echo -e "${RED}vault_repo not found in infra/terraform.tfvars${NC}"
  exit 1
fi

LOBBOSS_IP=$(get_lobboss_ip)
if [ -z "$LOBBOSS_IP" ]; then
  echo -e "${RED}Cannot resolve lobboss IP from Terraform state${NC}"
  exit 1
fi

if [ ! -d "$VAULT_LOCAL/.git" ]; then
  echo -e "${YELLOW}Cloning vault repo...${NC}"
  gh repo clone "$VAULT_REPO" "$VAULT_LOCAL"
fi

# --- Helpers ---

# Track state in temp files to avoid bash 4+ associative arrays (macOS compat)
STATE_DIR=$(mktemp -d)
trap 'rm -rf "$STATE_DIR"' EXIT

# Read a YAML frontmatter field from a task file
read_field() {
  local file="$1" field="$2"
  if [ ! -f "$file" ]; then
    return
  fi
  sed -n '/^---$/,/^---$/p' "$file" | grep "^${field}:" | head -1 | sed "s/^${field}:[[:space:]]*//"
}

# Find a task file across active/completed/failed directories
find_task_file() {
  local task_id="$1"
  for dir in active completed failed; do
    local path="$VAULT_LOCAL/010-tasks/$dir/${task_id}.md"
    if [ -f "$path" ]; then
      echo "$path"
      return
    fi
  done
}

echo ""
echo -e "${YELLOW}await-task-pickup${NC}  timeout=${TIMEOUT_MINUTES}m  tasks=${#TASK_IDS[@]}"
echo ""

# --- Initial status ---

git -C "$VAULT_LOCAL" checkout main --quiet 2>/dev/null || true
git -C "$VAULT_LOCAL" pull --quiet origin main 2>/dev/null || true

for TASK_ID in "${TASK_IDS[@]}"; do
  TASK_FILE=$(find_task_file "$TASK_ID")
  if [ -z "$TASK_FILE" ]; then
    echo -e "  ${RED}NOT FOUND${NC}  $TASK_ID"
    echo "not_found" > "$STATE_DIR/$TASK_ID"
  else
    STATUS=$(read_field "$TASK_FILE" "status")
    ASSIGNED=$(read_field "$TASK_FILE" "assigned_to")
    if [ "$STATUS" = "active" ] && [ -n "$ASSIGNED" ]; then
      echo -e "  ${GREEN}ALREADY ASSIGNED${NC}  $TASK_ID → $ASSIGNED"
      echo "active" > "$STATE_DIR/$TASK_ID"
      echo "$ASSIGNED" > "$STATE_DIR/${TASK_ID}.lobster"
    else
      echo -e "  ${CYAN}$STATUS${NC}  $TASK_ID"
      echo "$STATUS" > "$STATE_DIR/$TASK_ID"
    fi
  fi
done

echo ""
echo -e "Polling vault for assignment..."

# --- Poll loop ---

TIMEOUT_SECONDS=$((TIMEOUT_MINUTES * 60))
POLL_INTERVAL=15
ELAPSED=0

while [ "$ELAPSED" -lt "$TIMEOUT_SECONDS" ]; do
  # Pull latest
  git -C "$VAULT_LOCAL" pull --quiet origin main 2>/dev/null || true

  ALL_DONE=true

  for TASK_ID in "${TASK_IDS[@]}"; do
    CURRENT=$(cat "$STATE_DIR/$TASK_ID" 2>/dev/null || echo "unknown")

    # Skip tasks already resolved
    if [ "$CURRENT" = "active" ] || [ "$CURRENT" = "completed" ] || [ "$CURRENT" = "not_found" ]; then
      continue
    fi

    ALL_DONE=false

    TASK_FILE=$(find_task_file "$TASK_ID")
    if [ -z "$TASK_FILE" ]; then
      continue
    fi

    STATUS=$(read_field "$TASK_FILE" "status")
    ASSIGNED=$(read_field "$TASK_FILE" "assigned_to")

    if [ "$STATUS" = "active" ] && [ -n "$ASSIGNED" ]; then
      echo ""
      echo -e "  ${GREEN}PICKED UP${NC}  $TASK_ID → $ASSIGNED  (${ELAPSED}s)"
      echo "active" > "$STATE_DIR/$TASK_ID"
      echo "$ASSIGNED" > "$STATE_DIR/${TASK_ID}.lobster"
    elif [ "$STATUS" = "completed" ]; then
      echo ""
      echo -e "  ${GREEN}COMPLETED${NC}  $TASK_ID  (${ELAPSED}s)"
      echo "completed" > "$STATE_DIR/$TASK_ID"
    fi
  done

  if [ "$ALL_DONE" = true ]; then
    break
  fi

  sleep "$POLL_INTERVAL"
  ELAPSED=$((ELAPSED + POLL_INTERVAL))
  echo -n "."
done

echo ""

# --- Check lobster fleet ---

echo ""
echo -e "${YELLOW}Checking lobster fleet:${NC}"

LOBSTER_LIST=$(lobmob_ssh -o ConnectTimeout=10 "root@$LOBBOSS_IP" \
  'source /etc/lobmob/env && doctl compute droplet list --tag-name "$LOBSTER_TAG" --format Name,Status --no-header' 2>/dev/null || echo "")

if [ -n "$LOBSTER_LIST" ]; then
  echo "$LOBSTER_LIST" | while read -r line; do
    echo -e "  ${CYAN}droplet${NC}  $line"
  done
  echo ""
fi

# --- Summary ---

PASS=0
FAIL=0

for TASK_ID in "${TASK_IDS[@]}"; do
  STATUS=$(cat "$STATE_DIR/$TASK_ID" 2>/dev/null || echo "unknown")
  ASSIGNED=$(cat "$STATE_DIR/${TASK_ID}.lobster" 2>/dev/null || echo "")

  if [ "$STATUS" = "active" ] && [ -n "$ASSIGNED" ]; then
    if echo "$LOBSTER_LIST" | grep -q "$ASSIGNED"; then
      echo -e "  ${GREEN}PASS${NC}  $TASK_ID → $ASSIGNED (droplet running)"
      PASS=$((PASS + 1))
    else
      echo -e "  ${YELLOW}WARN${NC}  $TASK_ID → $ASSIGNED (assigned but droplet not found)"
      PASS=$((PASS + 1))  # Assignment happened, lobster may have been torn down
    fi
  elif [ "$STATUS" = "completed" ]; then
    echo -e "  ${GREEN}PASS${NC}  $TASK_ID (completed)"
    PASS=$((PASS + 1))
  elif [ "$STATUS" = "not_found" ]; then
    echo -e "  ${RED}FAIL${NC}  $TASK_ID (task file not found in vault)"
    FAIL=$((FAIL + 1))
  else
    echo -e "  ${RED}FAIL${NC}  $TASK_ID (still $STATUS after ${TIMEOUT_MINUTES}m)"
    FAIL=$((FAIL + 1))
  fi
done

TOTAL=$((PASS + FAIL))
echo ""
echo -e "${GREEN}$PASS${NC}/$TOTAL tasks picked up"
if [ "$FAIL" -gt 0 ]; then
  echo -e "${RED}$FAIL not picked up${NC}"
  exit 1
fi

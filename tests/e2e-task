#!/bin/bash
# e2e-task — full end-to-end task lifecycle test
# Usage: e2e-task [--title "..."] [--objective "..."] [--type research|swe|qa] [--timeout <minutes>]
#        LOBMOB_ENV=dev tests/e2e-task
#
# Stages:
#   1. Push     — create task file in vault
#   2. Pickup   — vault shows status: active, assigned_to set
#   3. Running  — k8s Job exists, pod past init containers
#   4. Complete — k8s Job succeeded (or failed → early exit)
#   5. PR       — lobster opens PR, review-prs merges it
#   6. Done     — task file has status: completed, result filled in
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
INFRA_DIR="$PROJECT_DIR/infra"
VAULT_LOCAL="$PROJECT_DIR/vault-local"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- Parse arguments ---

TITLE="Smoke test — write a haiku"
OBJECTIVE="Write a haiku about the ocean and save it to \`030-knowledge/topics/haiku-test.md\`"
LOBSTER_TYPE="research"
TIMEOUT_MINUTES=10

while [[ $# -gt 0 ]]; do
  case "$1" in
    --title)     TITLE="$2"; shift 2 ;;
    --objective) OBJECTIVE="$2"; shift 2 ;;
    --type)      LOBSTER_TYPE="$2"; shift 2 ;;
    --timeout)   TIMEOUT_MINUTES="$2"; shift 2 ;;
    --help|-h)
      echo "Usage: e2e-task [--title \"...\"] [--objective \"...\"] [--type research|swe|qa] [--timeout <minutes>]"
      echo "       LOBMOB_ENV=dev tests/e2e-task"
      echo ""
      echo "Runs full task lifecycle: push → pickup → execution → PR → completion"
      echo ""
      echo "Options:"
      echo "  --title      Task title (default: haiku smoke test)"
      echo "  --objective  Task objective (default: write a haiku)"
      echo "  --type       Lobster type: research, swe, qa (default: research)"
      echo "  --timeout    Max time in minutes for job execution stage (default: 10)"
      exit 0 ;;
    *) echo "Unknown option: $1"; exit 1 ;;
  esac
done

# --- Preflight ---

LOBMOB_ENV="${LOBMOB_ENV:-prod}"
if [[ "$LOBMOB_ENV" == "dev" ]]; then
  TFVARS_FILE="$INFRA_DIR/dev.tfvars"
  KUBE_CONTEXT="do-nyc3-lobmob-dev-k8s"
else
  TFVARS_FILE="$INFRA_DIR/prod.tfvars"
  KUBE_CONTEXT="do-nyc3-lobmob-k8s"
fi

VAULT_REPO=$(grep vault_repo "$TFVARS_FILE" 2>/dev/null | cut -d'"' -f2)
if [[ -z "$VAULT_REPO" ]]; then
  echo -e "${RED}vault_repo not found in ${TFVARS_FILE}${NC}"
  exit 1
fi

if ! kubectl --context "$KUBE_CONTEXT" cluster-info &>/dev/null; then
  echo -e "${RED}Cannot reach k8s cluster (context: $KUBE_CONTEXT)${NC}"
  exit 1
fi

# --- Helpers ---

read_field() {
  local file="$1" field="$2"
  if [[ ! -f "$file" ]]; then return; fi
  sed -n '/^---$/,/^---$/p' "$file" | grep "^${field}:" | head -1 | sed "s/^${field}:[[:space:]]*//"
}

find_task_file() {
  # Search by slug first, then by DB task_id (sync daemon renames slug -> T{id})
  for id in "$@"; do
    for dir in active completed failed; do
      local path="$VAULT_LOCAL/010-tasks/$dir/${id}.md"
      if [[ -f "$path" ]]; then
        echo "$path"
        return
      fi
    done
  done
}

sanitize_k8s_name() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g; s/-\{2,\}/-/g; s/^-//; s/-$//' | cut -c1-63
}

vault_pull() {
  git -C "$VAULT_LOCAL" checkout main --quiet 2>/dev/null || true
  git -C "$VAULT_LOCAL" pull --quiet origin main 2>/dev/null || true
}

# Stage timing
STAGE_TIMES=()
stage_start() { STAGE_START_TIME=$(date +%s); }
stage_end() {
  local now
  now=$(date +%s)
  STAGE_TIMES+=("$(( now - STAGE_START_TIME ))s")
}

# Result tracking
PASS=0
FAIL=0
pass() { echo -e "  ${GREEN}PASS${NC}  $1"; PASS=$((PASS + 1)); }
fail() { echo -e "  ${RED}FAIL${NC}  $1"; FAIL=$((FAIL + 1)); }

echo ""
echo -e "${YELLOW}e2e-task${NC}  env=${LOBMOB_ENV}  type=${LOBSTER_TYPE}  timeout=${TIMEOUT_MINUTES}m"
echo ""

# --- Clone or pull vault ---

if [[ -d "$VAULT_LOCAL/.git" ]]; then
  CURRENT_REMOTE=$(git -C "$VAULT_LOCAL" remote get-url origin 2>/dev/null || echo "")
  EXPECTED_SUFFIX="${VAULT_REPO}.git"
  if [[ "$CURRENT_REMOTE" != *"$EXPECTED_SUFFIX" ]] && [[ "$CURRENT_REMOTE" != *"$VAULT_REPO" ]]; then
    echo -e "${YELLOW}Vault remote mismatch. Re-cloning...${NC}"
    rm -rf "$VAULT_LOCAL"
    gh repo clone "$VAULT_REPO" "$VAULT_LOCAL"
    git -C "$VAULT_LOCAL" checkout main
  else
    vault_pull
  fi
else
  echo -e "${YELLOW}Cloning vault repo...${NC}"
  gh repo clone "$VAULT_REPO" "$VAULT_LOCAL"
  git -C "$VAULT_LOCAL" checkout main
fi

# ============================================================
# Stage 1: Push task
# ============================================================

echo -e "${CYAN}[1/6] Push task${NC}"
stage_start

TASK_ID="task-$(date +%Y-%m-%d)-$(openssl rand -hex 2)"
TASK_FILE_REL="010-tasks/active/${TASK_ID}.md"
TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

mkdir -p "$VAULT_LOCAL/010-tasks/active"

cat > "$VAULT_LOCAL/$TASK_FILE_REL" <<EOF
---
id: ${TASK_ID}
type: ${LOBSTER_TYPE}
status: queued
created: ${TIMESTAMP}
assigned_to:
assigned_at:
completed_at:
priority: normal
tags: [test]
---

# ${TITLE}

## Objective
${OBJECTIVE}

## Acceptance Criteria
- [ ] Task completed as described

## Lobster Notes
_To be filled by assigned lobster_

## Result
_Pending_
EOF

git -C "$VAULT_LOCAL" add "$TASK_FILE_REL"
git -C "$VAULT_LOCAL" commit -m "[test] Create ${TASK_ID}" --quiet
git -C "$VAULT_LOCAL" push origin main --quiet

# Register task in lobwife DB (Phase 2: poller reads from API)
LOBWIFE_SVC=$(kubectl --context "$KUBE_CONTEXT" -n lobmob get svc lobwife -o jsonpath='{.spec.clusterIP}' 2>/dev/null || echo "")
if [[ -n "$LOBWIFE_SVC" ]]; then
  API_CREATE=$(kubectl --context "$KUBE_CONTEXT" -n lobmob exec deployment/lobwife -- \
    curl -sf -X POST "http://localhost:8081/api/v1/tasks" \
    -H "Content-Type: application/json" \
    -d "{\"name\": \"${TITLE}\", \"type\": \"${LOBSTER_TYPE}\", \"slug\": \"${TASK_ID}\", \"actor\": \"e2e-test\"}" 2>/dev/null || echo "")
  if [[ -n "$API_CREATE" ]]; then
    DB_TASK_ID=$(echo "$API_CREATE" | python3 -c "import sys,json; print(json.load(sys.stdin).get('task_id',''))" 2>/dev/null || echo "")
    echo -e "       db: ${DB_TASK_ID} (registered via API)"
  else
    echo -e "       ${YELLOW}WARN: Failed to register in DB — poller may not pick up${NC}"
  fi
fi

stage_end
pass "Task pushed: ${TASK_ID}"
echo -e "       vault: ${VAULT_REPO}  file: ${TASK_FILE_REL}"
echo ""

# ============================================================
# Stage 2: Pickup — wait for status: active
# ============================================================

echo -e "${CYAN}[2/6] Await pickup${NC}"
stage_start

PICKUP_TIMEOUT=120
POLL_INTERVAL=15
ELAPSED=0
ASSIGNED_TO=""

while [[ "$ELAPSED" -lt "$PICKUP_TIMEOUT" ]]; do
  vault_pull
  TASK_FILE=$(find_task_file "$TASK_ID" "$DB_TASK_ID")
  if [[ -n "$TASK_FILE" ]]; then
    STATUS=$(read_field "$TASK_FILE" "status")
    ASSIGNED_TO=$(read_field "$TASK_FILE" "assigned_to")
    if [[ "$STATUS" == "active" ]] && [[ -n "$ASSIGNED_TO" ]]; then
      break
    fi
  fi
  sleep "$POLL_INTERVAL"
  ELAPSED=$((ELAPSED + POLL_INTERVAL))
  echo -n "."
done

if [[ -n "$ASSIGNED_TO" ]]; then
  stage_end
  pass "Picked up by ${ASSIGNED_TO} (${ELAPSED}s)"
else
  stage_end
  fail "Not picked up after ${PICKUP_TIMEOUT}s"
  echo ""
  echo -e "${RED}Aborting — task was not assigned.${NC}"
  echo -e "${PASS}/${PASS} passed, 1 failed, 4 skipped"
  exit 1
fi
echo ""

# ============================================================
# Stage 3: Job running — k8s Job exists, pod past init
# ============================================================

echo -e "${CYAN}[3/6] Job running${NC}"
stage_start

JOB_TIMEOUT=120
ELAPSED=0
# Use T-format ID for job label if available (Phase 2: poller labels with T-format)
if [[ -n "${DB_TASK_ID:-}" ]]; then
  SANITIZED=$(sanitize_k8s_name "$DB_TASK_ID")
else
  SANITIZED=$(sanitize_k8s_name "$TASK_ID")
fi
JOB_NAME=""
POD_PHASE=""

while [[ "$ELAPSED" -lt "$JOB_TIMEOUT" ]]; do
  JOB_NAME=$(kubectl --context "$KUBE_CONTEXT" -n lobmob get jobs \
    -l "lobmob.io/task-id=$SANITIZED" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

  if [[ -n "$JOB_NAME" ]]; then
    POD_PHASE=$(kubectl --context "$KUBE_CONTEXT" -n lobmob get pods \
      -l "job-name=$JOB_NAME" -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "")
    if [[ "$POD_PHASE" == "Running" ]] || [[ "$POD_PHASE" == "Succeeded" ]]; then
      break
    fi
  fi
  sleep "$POLL_INTERVAL"
  ELAPSED=$((ELAPSED + POLL_INTERVAL))
  echo -n "."
done

if [[ -n "$JOB_NAME" ]] && [[ -n "$POD_PHASE" ]]; then
  stage_end
  pass "Job ${JOB_NAME} (pod ${POD_PHASE}, ${ELAPSED}s)"
else
  stage_end
  if [[ -z "$JOB_NAME" ]]; then
    fail "No k8s Job found for ${SANITIZED} after ${JOB_TIMEOUT}s"
  else
    fail "Pod not running (phase: ${POD_PHASE:-unknown}) after ${JOB_TIMEOUT}s"
  fi
fi
echo ""

# ============================================================
# Stage 4: Job complete — wait for k8s Job succeeded/failed
# ============================================================

echo -e "${CYAN}[4/6] Job complete${NC}"
stage_start

JOB_COMPLETE_TIMEOUT=$((TIMEOUT_MINUTES * 60))
ELAPSED=0
JOB_SUCCEEDED=false
JOB_FAILED=false

if [[ -z "$JOB_NAME" ]]; then
  stage_end
  fail "Skipped — no job to watch"
else
  while [[ "$ELAPSED" -lt "$JOB_COMPLETE_TIMEOUT" ]]; do
    JOB_STATUS=$(kubectl --context "$KUBE_CONTEXT" -n lobmob get job "$JOB_NAME" \
      -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}' 2>/dev/null || echo "")
    JOB_FAIL_STATUS=$(kubectl --context "$KUBE_CONTEXT" -n lobmob get job "$JOB_NAME" \
      -o jsonpath='{.status.conditions[?(@.type=="Failed")].status}' 2>/dev/null || echo "")

    if [[ "$JOB_STATUS" == "True" ]]; then
      JOB_SUCCEEDED=true
      break
    elif [[ "$JOB_FAIL_STATUS" == "True" ]]; then
      JOB_FAILED=true
      break
    fi
    sleep "$POLL_INTERVAL"
    ELAPSED=$((ELAPSED + POLL_INTERVAL))
    echo -n "."
  done

  stage_end
  if [[ "$JOB_SUCCEEDED" == true ]]; then
    pass "Job succeeded (${ELAPSED}s)"
  elif [[ "$JOB_FAILED" == true ]]; then
    fail "Job failed (${ELAPSED}s)"
    echo ""
    echo -e "${RED}Job failed — check logs: lobmob --env ${LOBMOB_ENV} logs ${JOB_NAME}${NC}"
  else
    fail "Job still running after ${TIMEOUT_MINUTES}m"
  fi
fi
echo ""

# ============================================================
# Stage 5: PR merged — lobster opens PR, review-prs merges it
# ============================================================

echo -e "${CYAN}[5/6] PR merged${NC}"
stage_start

PR_TIMEOUT=300
ELAPSED=0
PR_NUMBER=""
PR_URL=""
PR_MERGED=false

while [[ "$ELAPSED" -lt "$PR_TIMEOUT" ]]; do
  # Look for PR (try T-format ID first, then slug)
  if [[ -z "$PR_NUMBER" ]]; then
    SEARCH_ID="${DB_TASK_ID:-$TASK_ID}"
    PR_JSON=$(gh pr list --repo "$VAULT_REPO" --state all --search "$SEARCH_ID" \
      --json number,url,state,headRefName \
      --jq ".[] | select(.headRefName | test(\"$SEARCH_ID|$TASK_ID\"; \"i\"))" 2>/dev/null || echo "")
    if [[ -n "$PR_JSON" ]]; then
      PR_NUMBER=$(echo "$PR_JSON" | head -1 | jq -r '.number' 2>/dev/null || echo "")
      PR_URL=$(echo "$PR_JSON" | head -1 | jq -r '.url' 2>/dev/null || echo "")
      PR_STATE=$(echo "$PR_JSON" | head -1 | jq -r '.state' 2>/dev/null || echo "")
      if [[ -n "$PR_NUMBER" ]]; then
        echo -e "  PR opened: #${PR_NUMBER} ${PR_URL}"
        if [[ "$PR_STATE" == "MERGED" ]]; then
          PR_MERGED=true
          break
        fi
      fi
    fi
  fi

  # Check merge status (if closed without merge, reset and look for retry PR)
  if [[ -n "$PR_NUMBER" ]] && [[ "$PR_MERGED" == false ]]; then
    PR_STATE=$(gh pr view "$PR_NUMBER" --repo "$VAULT_REPO" --json state --jq '.state' 2>/dev/null || echo "")
    if [[ "$PR_STATE" == "MERGED" ]]; then
      PR_MERGED=true
      break
    elif [[ "$PR_STATE" == "CLOSED" ]]; then
      echo -e " PR #${PR_NUMBER} closed (retry expected)"
      PR_NUMBER=""
      PR_URL=""
    fi
  fi

  sleep "$POLL_INTERVAL"
  ELAPSED=$((ELAPSED + POLL_INTERVAL))
  echo -n "."
done

stage_end
if [[ "$PR_MERGED" == true ]]; then
  pass "PR #${PR_NUMBER} merged (${ELAPSED}s)"
elif [[ -n "$PR_NUMBER" ]]; then
  fail "PR #${PR_NUMBER} not merged after ${PR_TIMEOUT}s"
else
  fail "No PR found after ${PR_TIMEOUT}s"
fi
echo ""

# ============================================================
# Stage 6: Task completed — verify vault state
# ============================================================

echo -e "${CYAN}[6/6] Task completed${NC}"
stage_start

DONE_TIMEOUT=120
ELAPSED=0
TASK_COMPLETED=false

while [[ "$ELAPSED" -lt "$DONE_TIMEOUT" ]]; do
  vault_pull
  TASK_FILE=$(find_task_file "$TASK_ID" "$DB_TASK_ID")
  if [[ -n "$TASK_FILE" ]]; then
    STATUS=$(read_field "$TASK_FILE" "status")
    if [[ "$STATUS" == "completed" ]]; then
      TASK_COMPLETED=true
      break
    fi
  fi
  sleep "$POLL_INTERVAL"
  ELAPSED=$((ELAPSED + POLL_INTERVAL))
  echo -n "."
done

if [[ "$TASK_COMPLETED" == true ]]; then
  stage_end

  # Verify task file contents
  COMPLETED_AT=$(read_field "$TASK_FILE" "completed_at")
  RESULT_SECTION=$(sed -n '/^## Result$/,/^## /p' "$TASK_FILE" | sed '1d;$d' | tr -d '[:space:]')
  NOTES_SECTION=$(sed -n '/^## Lobster Notes$/,/^## /p' "$TASK_FILE" | sed '1d;$d' | tr -d '[:space:]')

  pass "status: completed (${ELAPSED}s)"

  if [[ -n "$COMPLETED_AT" ]]; then
    pass "completed_at is set"
  else
    fail "completed_at is empty"
  fi

  if [[ "$RESULT_SECTION" != "_Pending_" ]] && [[ -n "$RESULT_SECTION" ]]; then
    pass "Result section filled in"
  else
    fail "Result section still pending"
  fi

  if [[ "$NOTES_SECTION" != "_Tobefilledbyassignedlobster_" ]] && [[ -n "$NOTES_SECTION" ]]; then
    pass "Lobster Notes filled in"
  else
    fail "Lobster Notes not filled in"
  fi

  # For the default haiku task, check the output file
  if [[ "$TITLE" == "Smoke test — write a haiku" ]]; then
    if [[ -f "$VAULT_LOCAL/030-knowledge/topics/haiku-test.md" ]]; then
      pass "Output file haiku-test.md exists"
    else
      fail "Output file haiku-test.md not found"
    fi
  fi
else
  stage_end
  fail "Task not completed after ${DONE_TIMEOUT}s"
fi
echo ""

# ============================================================
# Summary
# ============================================================

TOTAL=$((PASS + FAIL))
echo -e "${YELLOW}═══════════════════════════════════════${NC}"
echo -e "${YELLOW}Summary${NC}  ${TASK_ID}"
echo ""

# Print stage timing
STAGE_NAMES=("Push" "Pickup" "Running" "Complete" "PR" "Done")
for i in "${!STAGE_TIMES[@]}"; do
  echo -e "  ${STAGE_NAMES[$i]}: ${STAGE_TIMES[$i]}"
done
echo ""

echo -e "  ${GREEN}${PASS} passed${NC}, ${RED}${FAIL} failed${NC} (${TOTAL} checks)"

if [[ -n "${PR_URL:-}" ]]; then
  echo -e "  PR: ${PR_URL}"
fi
echo ""

if [[ "$FAIL" -gt 0 ]]; then
  exit 1
fi
